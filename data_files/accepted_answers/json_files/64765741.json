{
    "owner": {
        "reputation": 150340,
        "user_id": 264697,
        "user_type": "registered",
        "accept_rate": 100,
        "profile_image": "https://www.gravatar.com/avatar/53813b7dc989271bf45d1a047db31a1f?s=128&d=identicon&r=PG",
        "display_name": "Steven",
        "link": "https://stackoverflow.com/users/264697/steven"
    },
    "is_accepted": true,
    "score": 1,
    "last_activity_date": 1604998734,
    "creation_date": 1604998734,
    "answer_id": 64765741,
    "question_id": 64723643,
    "content_license": "CC BY-SA 4.0",
    "body": "<p>To prevent having to call <code>.Result</code> on <code>Channel</code>, you will have to await it. For instance:</p>\n<pre class=\"lang-cs prettyprint-override\"><code>var channel = await Channel;\nGetAllResponse getAllResponse =\n    await channel.GetAllAsync(new Google.Protobuf.WellKnownTypes.Empty());\n</code></pre>\n<p>Side note: As I mentioned in the comments, you should typically want to prevent doing anything that involves I/O during object resolution, becuase it makes object resolution fragile and untestable. Instead, you should be able to compose your object graphs with con confidence, as expressed <a href=\"https://blog.ploeh.dk/2011/03/04/Composeobjectgraphswithconfidence/\" rel=\"nofollow noreferrer\">here</a> by Mark Seemann. You can do this by postponing the creation of the Task by hiding it behind an abstraction. For instance:</p>\n<pre class=\"lang-cs prettyprint-override\"><code>public interface IGrpcChannelProvider\n{\n    Task&lt;GrpcChannel&gt; Channel { get; }\n}\n</code></pre>\n<p>This allows you to move all the registration code into an implementation for <code>IGrpcChannelProvider</code>:</p>\n<pre class=\"lang-cs prettyprint-override\"><code>public sealed class GrpcChannelProvider : IGrpcChannelProvider, IDisposable\n{\n    private readonly IConfiguration config;\n    private readonly IAccessTokenProvider authenticationService;\n\n    private readonly Lazy&lt;Task&lt;GrpcChannel&gt;&gt; channel;\n\n    public GrpcChannelProvider(\n        IConfiguration config, IAccessTokenProvider authenticationService)\n    {\n        this.config = config;\n        this.authenticationService = authenticationService;\n\n        this.channel = new Lazy&lt;Task&lt;GrpcChannel&gt;&gt;(this.CreateChannel);\n    }\n\n    public Task&lt;GrpcChannel&gt; Channel =&gt; this.channel.Value;\n\n    public void Dispose()\n    {\n        if (this.channel.IsValueCreated) this.channel.Value.Dispose();\n    }\n\n    // This is your original code\n    private async Task&lt;GrpcChannel&gt; CreateChannel()\n    {\n#if DEBUG\n        var baseUri = &quot;http://localhost:8999/&quot;;\n#else\nvar baseUri = &quot;[mysite]&quot;;\n#endif\n        var httpClient = new HttpClient(new GrpcWebHandler(GrpcWebMode.GrpcWeb, new HttpClientHandler()));\n\n        var tokenResult = await this.authenticationService.RequestAccessToken();\n\n        if (tokenResult.TryGetToken(out var token))\n        {\n            var credentials = CallCredentials.FromInterceptor((context, metadata) =&gt;\n            {\n                if (!string.IsNullOrEmpty(token.Value))\n                {\n                    metadata.Add(&quot;Authorization&quot;, $&quot;Bearer {token.Value}&quot;);\n                }\n                return Task.CompletedTask;\n            });\n\n            var channel = GrpcChannel.ForAddress(baseUri,\n                new GrpcChannelOptions\n                {\n                    HttpClient = httpClient,\n                    Credentials = ChannelCredentials.Create(new SslCredentials(), credentials)\n                });\n\n            var client = new GrpcServices.GrpcServicesClient(channel);\n            return client;\n        }\n    }\n}\n</code></pre>\n<p>This component can be registered as follows:</p>\n<pre class=\"lang-cs prettyprint-override\"><code>services.AddSingleton&lt;IGrpcChannelProvider, GrpcChannelProvider&gt;();\n</code></pre>\n<p>Or -in case caching the channel for the duration of the app domain causes security concerns- register the component as scoped:</p>\n<pre class=\"lang-cs prettyprint-override\"><code>services.AddScoped&lt;IGrpcChannelProvider, GrpcChannelProvider&gt;();\n</code></pre>\n<p>In the view, inject this <code>IGrpcChannelProvider</code> instead of the channel:</p>\n<pre class=\"lang-cs prettyprint-override\"><code>@inject IGrpcChannelProvider Provider\n</code></pre>\n<p>And use it as follows:</p>\n<pre class=\"lang-cs prettyprint-override\"><code>var channel = await Provider.Channel;\nGetAllResponse getAllResponse =\n    await channel.GetAllAsync(new Google.Protobuf.WellKnownTypes.Empty());\n</code></pre>\n<p>To take it one step further, you might even want to prevent doing any calls on services inside your Razor page, but instead rely on a pre-populated model:</p>\n<p>@model AllResponseModel</p>\n<pre class=\"lang-cs prettyprint-override\"><code>@model AllResponseModel\n\nGetAllResponse getAllResponse = Model.AllResponses;\n</code></pre>\n<p>Now you can inject <code>IGrpcChannelProvider</code> into the Razor <code>AllResponseModel</code> instead.</p>\n"
}