{
    "owner": {
        "reputation": 1016,
        "user_id": 7407434,
        "user_type": "registered",
        "profile_image": "https://www.gravatar.com/avatar/4f11cc64b569fab9a3199244fbbb9d83?s=128&d=identicon&r=PG&f=1",
        "display_name": "Randy",
        "link": "https://stackoverflow.com/users/7407434/randy"
    },
    "is_accepted": true,
    "score": 1,
    "last_activity_date": 1598838671,
    "creation_date": 1598838671,
    "answer_id": 63663780,
    "question_id": 63661946,
    "content_license": "CC BY-SA 4.0",
    "body": "<p><strong>What's happening</strong></p>\n<p>The specific mixing of the <a href=\"https://github.com/dotnet/aspnetcore/blob/master/src/Mvc/Mvc.Core/src/Authorization/AuthorizeFilter.cs\" rel=\"nofollow noreferrer\">AuthorizeFilter</a> on your controller endpoint and the usage of the <a href=\"https://github.com/dotnet/aspnetcore/blob/4e44025a52e4b73aa17e09a8041b0e166e0c5ce0/src/Identity/ApiAuthorization.IdentityServer/src/Authentication/AuthenticationBuilderExtensions.cs#L33\" rel=\"nofollow noreferrer\">AddIdentityServerJwt</a> on your authentication builder is probably the culprit here. AddIdentityServerJwt <a href=\"https://github.com/dotnet/aspnetcore/blob/4e44025a52e4b73aa17e09a8041b0e166e0c5ce0/src/Identity/ApiAuthorization.IdentityServer/src/Authentication/AuthenticationBuilderExtensions.cs#L40\" rel=\"nofollow noreferrer\">adds the Jwt authentication scheme as the default authentication scheme</a> indicated by the passage of the authentication scheme name in the AddAuthentication method. This means that the handler associated with this Jwt authentication scheme (<a href=\"https://github.com/dotnet/aspnetcore/blob/f3b370c1ac986312db5824b1735c9bb3ee3117c4/src/Security/Authentication/JwtBearer/src/JwtBearerHandler.cs#L22\" rel=\"nofollow noreferrer\">JwtBearerHandler</a>) will be the class that's emitting the 401 through its <a href=\"https://github.com/dotnet/aspnetcore/blob/f3b370c1ac986312db5824b1735c9bb3ee3117c4/src/Security/Authentication/JwtBearer/src/JwtBearerHandler.cs#L195\" rel=\"nofollow noreferrer\">HandleChallengeAsync</a> method. Notice there's no redirect for further action in this method which is why you don't see a redirect occurring.</p>\n<p><strong>Why is this happening?</strong></p>\n<p>The HandleChallengeAsync method on the JwtBearerHandler is invoked because of the AuthorizeFilter on your controller endpoint. The method that executes the AuthorizeFilter is the <a href=\"https://github.com/dotnet/aspnetcore/blob/master/src/Mvc/Mvc.Core/src/Authorization/AuthorizeFilter.cs#L167\" rel=\"nofollow noreferrer\">OnAuthorizationAsync</a> method (<a href=\"https://github.com/dotnet/aspnetcore/blob/master/src/Mvc/Mvc.Core/src/Authorization/AuthorizeFilter.cs#L208\" rel=\"nofollow noreferrer\">which is invoked right after the initialization of the filter</a>). Since there's no policy specified in the Authorization attribute put on your controller (there was nothing passed in as a parameter in <code>[Authorize]</code>), the default authorization policy ends up being used. The default policy basically checks if any of the authentication schemes have successfully authenticated you (by looking at the identities in the HttpContext), and return a <a href=\"https://github.com/dotnet/aspnetcore/blob/master/src/Mvc/Mvc.Core/src/Authorization/AuthorizeFilter.cs#L200\" rel=\"nofollow noreferrer\">response for a challenge if not</a>. This challenge defaults to the challenge of the default authentication scheme which is why HandleChallengeAsync is called on the JwtBearerHandler.</p>\n<p>You can learn more about policies <a href=\"https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-3.1\" rel=\"nofollow noreferrer\">here</a>, and more about the AuthorizationFilter (and filters in general) <a href=\"https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-3.1#authorization-filters\" rel=\"nofollow noreferrer\">here</a>.</p>\n"
}