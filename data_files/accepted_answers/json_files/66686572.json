{
    "owner": {
        "reputation": 3252,
        "user_id": 845356,
        "user_type": "registered",
        "accept_rate": 79,
        "profile_image": "https://www.gravatar.com/avatar/300474536742f11884ed9c9bc0e1fe08?s=128&d=identicon&r=PG&f=1",
        "display_name": "Whit Waldo",
        "link": "https://stackoverflow.com/users/845356/whit-waldo"
    },
    "is_accepted": true,
    "score": 1,
    "last_activity_date": 1616052762,
    "creation_date": 1616052762,
    "answer_id": 66686572,
    "question_id": 61684831,
    "content_license": "CC BY-SA 4.0",
    "body": "<p>We use Blazor server-side as the front-end to a collection of microservices running in Azure Service Fabric (itself a stateless ASP.NET Core service), so it's a perfectly legitimate scenario. Our whole application runs within Azure's cloud, so I'll use its products to describe our implementation.</p>\n<p>In order to better separate concerns and more readily secure internet boundaries, we have two separate services for the public API and for SignalR. The API Gateway thus serves as a security boundary since it can handle HTTPS offloading, sit on a public-facing subnet and route to an internal service on the virtual network. The service providing SignalR access then runs on a public-facing subnet behind an Application Gateway instance (for the firewall + service routing functionality).</p>\n<p>As such, we have the two services set up as follows:</p>\n<h2>SignalR Service</h2>\n<p>[Browser] -- (SignalR) -- [Azure Application Gateway] -- [Azure Service Fabric - Blazor Server-side App] -- [SF Service Remoting] -- [Microservices]</p>\n<h2>API Service</h2>\n<p>[Browser] -- (https) -- [Azure API Management] -- (http) -- [Azure Service Fabric - ASP.NET Core API] -- [SF Service Remoting] -- [Microservices]</p>\n<h2>Microservice Gotcha - Data Protection</h2>\n<p>Especially when supporting authentication, ASP.NET Core sets up some keys internally for encrypting state used in the Blazor session. In a microservices scenario, unless you've got sticky routing all the way through your networking stack (load balancers, gateways, routers, etc.) to ensure that all requests always hit the same instance (and that presumably your instance isn't rebuilt and moved elsewhere when you're not paying attention), you're going to run into vague and unhelpful errors about failing to unprotect the state.</p>\n<p>The fix is quite simple - in the Startup.cs of your ASP.NET Core services, ensure you set up <code>services.AddDataProtection();</code> and configure appropriately. Since we're using Service Fabric, there's a <a href=\"https://service-fabric-data-protection.socreate.it\" rel=\"nofollow noreferrer\">third-party library</a> we use that works quite well for this purpose. To use, install the NuGet package <code>SoCreate.AspNetCore.DatapProtection.ServiceFabric</code> to your ASP.NET Core service(s) and simply put the following in your Startup.cs within the <code>ConfigureServices()</code> method:</p>\n<pre class=\"lang-cs prettyprint-override\"><code>public void ConfigureServices(IServiceCollection services)\n{\n  //...\n  services.AddDataProtection().PersistKeysToServiceFabricDistributedCache(opt =&gt; {\n    //Unique for this ASP.NET Core microservice, don't use a new GUID each time or you'll be back where you started without a single store for all the services\n    opt.CacheStoreId = new Guid(&quot;b87d03b5-f8d1-456f-966d-11d2c4d9774d&quot;); \n\n    //Specifically points to the service to use - if not set, it'll be automatically discovered\n    opt.CacheStoreServiceUri = new Uri(&quot;fabric:/MyApplication/DataProtectionStore&quot;);   });\n  //...\n}\n</code></pre>\n<p>There are additional options you can specify on the latter method to identify the specific service it should use and a unique ID (so the service can be shared across applications), but if it's in the same application and you don't specify these options, it'll find it itself.</p>\n<p>Then create up a stateful service instance, install <code>SoCreate.Extensions.Caching.ServiceFabric</code> from NuGet in the file reflecting the name of the service and replace its inheritance from <code>StatefulService</code> to instead have it inherit from <code>DistributedCacheStoreService</code>. Delete everything else in the service, but set up the updated constructor. In a service named &quot;DataProtectionStore&quot;, your <code>DataProtectionStore.cs</code> file should look like the following:</p>\n<pre class=\"lang-cs prettyprint-override\"><code>using System.Fabric;\nusing SoCreate.Extensions.Caching.ServiceFabric\n\nnamespace DataProtectionStore\n{\n  internal sealed class DataProtectionStore : DistributedCacheStoreService\n  {\n    protected override int MaxCacheSizeInMegabytes =&gt; 500; //Optional\n\n    public DataProtectionStore(StatefulServiceContext context) : base(context, message =&gt; ServiceEventSource.Current.ServiceMessage(context, message))\n    {\n    }\n  }\n}\n</code></pre>\n<p>You can find other helpful guidance specific to hosting ASP.NET Core in a &quot;web farm&quot; or microservices/distributed environment <a href=\"https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/web-farm?view=aspnetcore-5.0\" rel=\"nofollow noreferrer\">here</a>.</p>\n"
}