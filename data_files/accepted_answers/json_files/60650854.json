{
    "owner": {
        "reputation": 1040,
        "user_id": 2969412,
        "user_type": "registered",
        "accept_rate": 57,
        "profile_image": "https://www.gravatar.com/avatar/2400c042e8661dccb01771f598b8acf0?s=128&d=identicon&r=PG&f=1",
        "display_name": "Morten_564834",
        "link": "https://stackoverflow.com/users/2969412/morten-564834"
    },
    "is_accepted": true,
    "score": 0,
    "last_activity_date": 1584005367,
    "last_edit_date": 1584005367,
    "creation_date": 1584004567,
    "answer_id": 60650854,
    "question_id": 60360640,
    "content_license": "CC BY-SA 4.0",
    "body": "<p>Ok so I have now worked out an approach. I'll share it here.</p>\n\n<p>The thing is that you can either dennormalize the table, aka. make the entities with all its nested objects and list properties into 1 tableentity => 1 row. This implies that complex properties or classtype properties needs to be serialized into strings (json most likely).</p>\n\n<p>Or you can make relationships, where the entities are sharing the same partitionkey. Then create them in batch. E.g. Department -> Persons. So a Department has partionkey = Department01 and Person X has partionkey = Department01. 2 rows.</p>\n\n<p>But what if you actually want to do both, say have different rows, but each tableentity also has IEnumerable properties like lists and collections that would be overkill to separate into different rows aswell. </p>\n\n<p>I found this great community library that I expanded on and made 2 generic methods. They are not perfect, but it's a start.</p>\n\n<p><a href=\"https://github.com/giometrix/TableStorage.Abstractions.POCO\" rel=\"nofollow noreferrer\">https://github.com/giometrix/TableStorage.Abstractions.POCO</a></p>\n\n<p>Here you can easily convert a POCO entity into a TableEntity and vice versa, aka. denormalizing. </p>\n\n<p>I added these 2 generic methods to the library:</p>\n\n<pre><code>/// &lt;summary&gt;\n    /// Adds relationship One To Many between source (one) and related entitiy targets (many). Source and related targets have seperate rows but share the same partition key\n    /// &lt;/summary&gt;\n    /// &lt;typeparam name=\"TTarget\"&gt;Target class, ex. Persons&lt;/typeparam&gt;\n    /// &lt;param name=\"entitySource\"&gt;Source entity that only has one entry&lt;/param&gt;\n    /// &lt;param name=\"relatedEntities\"&gt;Related entities contained in source entity, this can be 0 to many, ex. e =&gt; e.Persons&lt;/param&gt;\n    /// &lt;param name=\"entityTargetRowKey\"&gt;Target entity rowkey property, needs to be different than source rowkey&lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n\n    public async Task InsertBatchOneToMany&lt;TTarget&gt;(T entitySource, Expression&lt;Func&lt;T, IEnumerable&lt;TTarget&gt;&gt;&gt; relatedEntities, Expression&lt;Func&lt;TTarget, string&gt;&gt; entityTargetRowKey)  where TTarget : class\n    {\n        try\n        {\n            //TODO: Put related property on ignorelist for json serializing\n\n            //Create the batch operation\n            TableBatchOperation batchOperation = new TableBatchOperation();\n\n            IEnumerable&lt;TTarget&gt; targets = relatedEntities.Compile().Invoke(entitySource);\n\n            //Insert source entity to batch\n            DynamicTableEntity source = CreateEntity(entitySource);\n            batchOperation.InsertOrMerge(source);\n\n            //Insert target entities to batch\n            foreach (var entityTarget in targets)\n            {\n                string trowKey = entityTargetRowKey.Compile().Invoke(entityTarget);\n                batchOperation.InsertOrMerge(entityTarget.ToTableEntity(source.PartitionKey, trowKey));\n            }\n\n            //Execute batch\n            IList&lt;TableResult&gt; results = await _table.ExecuteBatchAsync(batchOperation);\n        }\n        catch (StorageException ex)\n        {\n            throw new StorageException($\"Error saving data to Table.\" +\n                $\"{ System.Environment.NewLine}Error Message: {ex.Message}\" +\n                $\"{ System.Environment.NewLine}Error Extended Information: {ex.RequestInformation.ExtendedErrorInformation.ErrorMessage}\" +\n                $\"{ System.Environment.NewLine}Error Code: {ex.RequestInformation.ExtendedErrorInformation.ErrorCode}\");\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Retrieve source and its related target entities back again to source\n    /// &lt;/summary&gt;\n    /// &lt;typeparam name=\"TTarget\"&gt;Related Entity&lt;/typeparam&gt;\n    /// &lt;param name=\"partitionKey\"&gt;Partionkey shared by source and related target entities&lt;/param&gt;\n    /// &lt;param name=\"relatedEntities\"&gt;Related entities contained in source entity, ex. e =&gt; e.Persons&lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n\n    public async Task&lt;T&gt; GetBatchOneToMany&lt;TTarget&gt;(string partitionKey, Expression&lt;Func&lt;T, IEnumerable&lt;TTarget&gt;&gt;&gt; relatedEntities) where TTarget : class, new()\n    {\n        var dynTableEntities = await _tableStore.GetByPartitionKeyAsync(partitionKey);\n\n        T convertSource = new T();\n        TTarget convertTarget = new TTarget();\n\n        var targetObjects = new List&lt;TTarget&gt;();\n        MemberExpression member = relatedEntities.Body as MemberExpression;\n        PropertyInfo propInfo = member.Member as PropertyInfo;\n\n        IEnumerable&lt;TTarget&gt; targets = relatedEntities.Compile().Invoke(convertSource);\n\n        bool sourceFound = false;\n        foreach (var dynTableEntity in dynTableEntities)\n        {\n            //Try convert to source\n            int nonNullValuesSource = 0;\n            int nonNullValuesTarget = 0;\n            if (!sourceFound)\n            {\n                convertSource = dynTableEntity.FromTableEntity&lt;T&gt;();\n                nonNullValuesSource = convertSource.GetType().GetProperties().Select(x =&gt; x.GetValue(convertSource)).Count(v =&gt; v != null);\n            }\n            //Try convert to target\n            convertTarget = dynTableEntity.FromTableEntity&lt;TTarget&gt;();\n            nonNullValuesTarget = convertTarget.GetType().GetProperties().Select(x =&gt; x.GetValue(convertTarget)).Count(v =&gt; v != null);\n\n            if (nonNullValuesSource &gt; nonNullValuesTarget)\n            {\n                sourceFound = true;\n            }\n            else\n            {\n                targetObjects.Add(convertTarget);\n            }\n        }\n\n        propInfo.SetValue(convertSource, targetObjects);\n        return convertSource;\n\n    }\n</code></pre>\n\n<p>This allows me to make relationships and denormalize the rows at the same time. </p>\n\n<p>Usage:</p>\n\n<pre><code> public async Task AddProject(GovernorProject project)\n    {\n\n        //Commit to table\n        await _repository.InsertBatchOneToMany(project, p =&gt; p.Environments, e =&gt; e.DisplayName);\n    }\n\n\npublic async Task&lt;GovernorProject&gt; GetProject(string projectId)\n    {\n        return await _repository.GetBatchOneToMany(projectId, p =&gt; p.Environments);\n\n    }\n</code></pre>\n\n<p>In my case here, I have a main entity of a Project and each project have 0 or more Environments related which is held on a <code>Collection&lt;Environment&gt; Environment</code> property on the GovernorProject</p>\n"
}