{
    "owner": {
        "user_type": "does_not_exist",
        "display_name": "user7340499"
    },
    "is_accepted": true,
    "score": 4,
    "last_activity_date": 1524447778,
    "last_edit_date": 1524447778,
    "creation_date": 1523895860,
    "answer_id": 49862020,
    "question_id": 49776226,
    "content_license": "CC BY-SA 3.0",
    "body": "<p>I managed to create a small (library-ish) code snippet in C. I checked the results from <a href=\"https://www.freeformatter.com/hmac-generator.html#ad-output\" rel=\"nofollow noreferrer\">here</a>.</p>\n\n<p>Also shown here:\n<a href=\"https://i.stack.imgur.com/5gesg.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/5gesg.png\" alt=\"enter image description here\"></a></p>\n\n<p>The SHA256 code is taken from <a href=\"https://github.com/ckolivas/cgminer\" rel=\"nofollow noreferrer\">here</a>. Used in cgminer.</p>\n\n<p>I just modified it a bit (removed references etc.) to make it work stand-alone. Here is the total code and test software.</p>\n\n<blockquote>\n  <p>sha2.h:</p>\n</blockquote>\n\n<pre><code>/*\n * FIPS 180-2 SHA-224/256/384/512 implementation\n * Last update: 02/02/2007\n * Issue date:  04/30/2005\n *\n * Copyright (C) 2013, Con Kolivas &lt;kernel@kolivas.org&gt;\n * Copyright (C) 2005, 2007 Olivier Gay &lt;olivier.gay@a3.epfl.ch&gt;\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the project nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#ifndef SHA2_H\n#define SHA2_H\n\n#define SHA256_DIGEST_SIZE ( 256 / 8)\n#define SHA256_BLOCK_SIZE  ( 512 / 8)\n\n#define SHFR(x, n)    (x &gt;&gt; n)\n#define ROTR(x, n)   ((x &gt;&gt; n) | (x &lt;&lt; ((sizeof(x) &lt;&lt; 3) - n)))\n#define CH(x, y, z)  ((x &amp; y) ^ (~x &amp; z))\n#define MAJ(x, y, z) ((x &amp; y) ^ (x &amp; z) ^ (y &amp; z))\n\n#define SHA256_F1(x) (ROTR(x,  2) ^ ROTR(x, 13) ^ ROTR(x, 22))\n#define SHA256_F2(x) (ROTR(x,  6) ^ ROTR(x, 11) ^ ROTR(x, 25))\n#define SHA256_F3(x) (ROTR(x,  7) ^ ROTR(x, 18) ^ SHFR(x,  3))\n#define SHA256_F4(x) (ROTR(x, 17) ^ ROTR(x, 19) ^ SHFR(x, 10))\n\ntypedef struct {\n    unsigned int tot_len;\n    unsigned int len;\n    unsigned char block[2 * SHA256_BLOCK_SIZE];\n    unsigned int h[8];\n} sha256_ctx;\n\nextern unsigned int sha256_k[64];\n\nvoid sha256_init(sha256_ctx * ctx);\nvoid sha256_update(sha256_ctx *ctx, const unsigned char *message,\n                   unsigned int len);\nvoid sha256_final(sha256_ctx *ctx, unsigned char *digest);\nvoid sha256(const unsigned char *message, unsigned int len,\n            unsigned char *digest);\n\n#endif /* !SHA2_H */\n</code></pre>\n\n<blockquote>\n  <p>main.c:</p>\n</blockquote>\n\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#include \"sha2.h\"\n\n#define UNPACK32(x, str)                      \\\n{                                             \\\n*((str) + 3) = (unsigned char) ((x)      );       \\\n*((str) + 2) = (unsigned char) ((x) &gt;&gt;  8);       \\\n*((str) + 1) = (unsigned char) ((x) &gt;&gt; 16);       \\\n*((str) + 0) = (unsigned char) ((x) &gt;&gt; 24);       \\\n}\n\n#define PACK32(str, x)                        \\\n{                                             \\\n*(x) =   ((unsigned int) *((str) + 3)      )    \\\n| ((unsigned int) *((str) + 2) &lt;&lt;  8)    \\\n| ((unsigned int) *((str) + 1) &lt;&lt; 16)    \\\n| ((unsigned int) *((str) + 0) &lt;&lt; 24);   \\\n}\n\n#define SHA256_SCR(i)                         \\\n{                                             \\\nw[i] =  SHA256_F4(w[i -  2]) + w[i -  7]  \\\n+ SHA256_F3(w[i - 15]) + w[i - 16]; \\\n}\n\nunsigned int sha256_h0[8] =\n{ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 };\n\nunsigned int sha256_k[64] =\n{ 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2 };\n\n/* SHA-256 functions */\n\nvoid sha256_transf(sha256_ctx *ctx, const unsigned char *message,\n                   unsigned int block_nb)\n{\n    unsigned int w[64];\n    unsigned int wv[8];\n    unsigned int t1, t2;\n    const unsigned char *sub_block;\n    int i;\n\n    int j;\n\n    for (i = 0; i &lt; (int)block_nb; i++) {\n        sub_block = message + (i &lt;&lt; 6);\n\n        for (j = 0; j &lt; 16; j++) {\n            PACK32(&amp;sub_block[j &lt;&lt; 2], &amp;w[j]);\n        }\n\n        for (j = 16; j &lt; 64; j++) {\n            SHA256_SCR(j);\n        }\n\n        for (j = 0; j &lt; 8; j++) {\n            wv[j] = ctx-&gt;h[j];\n        }\n\n        for (j = 0; j &lt; 64; j++) {\n            t1 = wv[7] + SHA256_F2(wv[4]) + CH(wv[4], wv[5], wv[6])\n            + sha256_k[j] + w[j];\n            t2 = SHA256_F1(wv[0]) + MAJ(wv[0], wv[1], wv[2]);\n            wv[7] = wv[6];\n            wv[6] = wv[5];\n            wv[5] = wv[4];\n            wv[4] = wv[3] + t1;\n            wv[3] = wv[2];\n            wv[2] = wv[1];\n            wv[1] = wv[0];\n            wv[0] = t1 + t2;\n        }\n\n        for (j = 0; j &lt; 8; j++) {\n            ctx-&gt;h[j] += wv[j];\n        }\n    }\n}\n\nvoid sha256(const unsigned char *message, unsigned int len, unsigned char *digest)\n{\n    sha256_ctx ctx;\n\n    sha256_init(&amp;ctx);\n    sha256_update(&amp;ctx, message, len);\n    sha256_final(&amp;ctx, digest);\n}\n\nvoid sha256_init(sha256_ctx *ctx)\n{\n    int i;\n    for (i = 0; i &lt; 8; i++) {\n        ctx-&gt;h[i] = sha256_h0[i];\n    }\n\n    ctx-&gt;len = 0;\n    ctx-&gt;tot_len = 0;\n}\n\nvoid sha256_update(sha256_ctx *ctx, const unsigned char *message,\n                   unsigned int len)\n{\n    unsigned int block_nb;\n    unsigned int new_len, rem_len, tmp_len;\n    const unsigned char *shifted_message;\n\n    tmp_len = SHA256_BLOCK_SIZE - ctx-&gt;len;\n    rem_len = len &lt; tmp_len ? len : tmp_len;\n\n    memcpy(&amp;ctx-&gt;block[ctx-&gt;len], message, rem_len);\n\n    if (ctx-&gt;len + len &lt; SHA256_BLOCK_SIZE) {\n        ctx-&gt;len += len;\n        return;\n    }\n\n    new_len = len - rem_len;\n    block_nb = new_len / SHA256_BLOCK_SIZE;\n\n    shifted_message = message + rem_len;\n\n    sha256_transf(ctx, ctx-&gt;block, 1);\n    sha256_transf(ctx, shifted_message, block_nb);\n\n    rem_len = new_len % SHA256_BLOCK_SIZE;\n\n    memcpy(ctx-&gt;block, &amp;shifted_message[block_nb &lt;&lt; 6],\n           rem_len);\n\n    ctx-&gt;len = rem_len;\n    ctx-&gt;tot_len += (block_nb + 1) &lt;&lt; 6;\n}\n\nvoid sha256_final(sha256_ctx *ctx, unsigned char *digest)\n{\n    unsigned int block_nb;\n    unsigned int pm_len;\n    unsigned int len_b;\n\n    int i;\n\n    block_nb = (1 + ((SHA256_BLOCK_SIZE - 9)\n                     &lt; (ctx-&gt;len % SHA256_BLOCK_SIZE)));\n\n    len_b = (ctx-&gt;tot_len + ctx-&gt;len) &lt;&lt; 3;\n    pm_len = block_nb &lt;&lt; 6;\n\n    memset(ctx-&gt;block + ctx-&gt;len, 0, pm_len - ctx-&gt;len);\n    ctx-&gt;block[ctx-&gt;len] = 0x80;\n    UNPACK32(len_b, ctx-&gt;block + pm_len - 4);\n\n    sha256_transf(ctx, ctx-&gt;block, block_nb);\n\n    for (i = 0; i &lt; 8; i++) {\n        UNPACK32(ctx-&gt;h[i], &amp;digest[i &lt;&lt; 2]);\n    }\n}\n\nunsigned char * HMAC_SHA256(const char * msg, const char * key)\n{\n    unsigned int blocksize = 64;\n    unsigned char * Key0 = (unsigned char *)calloc(blocksize, sizeof(unsigned char));\n    unsigned char * Key0_ipad = (unsigned char *)calloc(blocksize, sizeof(unsigned char));\n    unsigned char * Key0_ipad_concat_text = (unsigned char *)calloc( (blocksize + strlen(msg)), sizeof(unsigned char));\n    unsigned char * Key0_ipad_concat_text_digest = (unsigned char *)calloc( blocksize, sizeof(unsigned char));\n    unsigned char * Key0_opad = (unsigned char *)calloc(blocksize, sizeof(unsigned char));\n    unsigned char * Key0_opad_concat_prev = (unsigned char *)calloc(blocksize + 32, sizeof(unsigned char));\n\n    unsigned char * HMAC_SHA256 = (unsigned char *)malloc(32 * sizeof(unsigned char));\n\n    if (strlen(key) &lt; blocksize) {\n        for (int i = 0; i &lt; blocksize; i++) {\n            if (i &lt; strlen(key)) Key0[i] = key[i];\n            else Key0[i] = 0x00;\n        }\n    }\n    else if (strlen(key) &gt; blocksize) {\n        sha256(key, strlen(key), Key0);\n        for (unsigned char i = strlen(key); i &lt; blocksize; i++) {\n            Key0[i] = 0x00;\n        }\n    }\n\n    for (int i = 0; i &lt; blocksize; i++) {\n        Key0_ipad[i] = Key0[i] ^ 0x36;\n    }\n    for (int i = 0; i &lt; blocksize; i++) {\n        Key0_ipad_concat_text[i] = Key0_ipad[i];\n    }\n    for (int i = blocksize; i &lt; blocksize + strlen(msg); i++) {\n        Key0_ipad_concat_text[i] = msg[i - blocksize];\n    }\n\n    sha256(Key0_ipad_concat_text, blocksize + (unsigned int)strlen(msg), Key0_ipad_concat_text_digest);\n\n    for (int i = 0; i &lt; blocksize; i++) {\n        Key0_opad[i] = Key0[i] ^ 0x5C;\n    }\n\n    for (int i = 0; i &lt; blocksize; i++) {\n        Key0_opad_concat_prev[i] = Key0_opad[i];\n    }\n    for (int i = blocksize; i &lt; blocksize + 32; i++) {\n        Key0_opad_concat_prev[i] = Key0_ipad_concat_text_digest[i - blocksize];\n    }\n\n    sha256(Key0_opad_concat_prev, blocksize + 32, HMAC_SHA256);\n    return HMAC_SHA256;\n}\n\n\nint main()\n{\n    unsigned char * result;\n\n    result = HMAC_SHA256(\"Sample #1\", \"MyKey\");\n\n    unsigned char arr[32] = { 0 };\n    memcpy(arr, result, 32);\n\n    for(int i = 0; i &lt; 32; i++) {\n        printf(\"%#02x, \", arr[i]);\n    }\n    return 0;\n}\n</code></pre>\n\n<p>Here are the results for the sample run:</p>\n\n<p><a href=\"https://i.stack.imgur.com/3MOty.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/3MOty.png\" alt=\"enter image description here\"></a></p>\n\n<p><a href=\"https://i.stack.imgur.com/NrPh9.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/NrPh9.png\" alt=\"enter image description here\"></a></p>\n\n<p>EDIT: </p>\n\n<p>Info on the HMAC_SHA256 function can be found <a href=\"https://csrc.nist.gov/csrc/media/publications/fips/198/archive/2002-03-06/documents/fips-198a.pdf\" rel=\"nofollow noreferrer\">here</a>. The one I wrote is just for demonstration purposes. One can modify it accordingly.</p>\n\n<p>EDIT 2: </p>\n\n<p>I added the code for Base64 format. I used the information found on Wikipedia. Sample test run works for OP's input and output. Results are as shown:</p>\n\n<p><a href=\"https://i.stack.imgur.com/fHiBM.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/fHiBM.png\" alt=\"Computed HMAC_SHA256 of &quot;test&quot; and &quot;secret&quot;\"></a>\n<a href=\"https://i.stack.imgur.com/veHKX.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/veHKX.png\" alt=\"main.c results for &quot;test&quot; and &quot;secret&quot;\"></a></p>\n\n<blockquote>\n  <p>Updated main.c</p>\n</blockquote>\n\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;errno.h&gt;\n\n#include \"sha2.h\"\n\n#define HMAC_SHA256_FAIL_STRING \"HMAC_SHA256 has failed.\" // fprintf(stderr, \"%s\\n\", strerror(errno));\n\n#define UNPACK32(x, str)                      \\\n{                                             \\\n*((str) + 3) = (unsigned char) ((x)      );       \\\n*((str) + 2) = (unsigned char) ((x) &gt;&gt;  8);       \\\n*((str) + 1) = (unsigned char) ((x) &gt;&gt; 16);       \\\n*((str) + 0) = (unsigned char) ((x) &gt;&gt; 24);       \\\n}\n\n#define PACK32(str, x)                        \\\n{                                             \\\n*(x) =   ((unsigned int) *((str) + 3)      )    \\\n| ((unsigned int) *((str) + 2) &lt;&lt;  8)    \\\n| ((unsigned int) *((str) + 1) &lt;&lt; 16)    \\\n| ((unsigned int) *((str) + 0) &lt;&lt; 24);   \\\n}\n\n#define SHA256_SCR(i)                         \\\n{                                             \\\nw[i] =  SHA256_F4(w[i -  2]) + w[i -  7]  \\\n+ SHA256_F3(w[i - 15]) + w[i - 16]; \\\n}\n\nchar Base64_Table[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nunsigned int sha256_h0[8] =\n{ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 };\n\nunsigned int sha256_k[64] =\n{ 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2 };\n\n/* SHA-256 functions */\n\nvoid sha256_transf(sha256_ctx *ctx, const unsigned char *message,\n                   unsigned int block_nb)\n{\n    unsigned int w[64];\n    unsigned int wv[8];\n    unsigned int t1, t2;\n    const unsigned char *sub_block;\n    int i;\n\n    int j;\n\n    for (i = 0; i &lt; (int)block_nb; i++) {\n        sub_block = message + (i &lt;&lt; 6);\n\n        for (j = 0; j &lt; 16; j++) {\n            PACK32(&amp;sub_block[j &lt;&lt; 2], &amp;w[j]);\n        }\n\n        for (j = 16; j &lt; 64; j++) {\n            SHA256_SCR(j);\n        }\n\n        for (j = 0; j &lt; 8; j++) {\n            wv[j] = ctx-&gt;h[j];\n        }\n\n        for (j = 0; j &lt; 64; j++) {\n            t1 = wv[7] + SHA256_F2(wv[4]) + CH(wv[4], wv[5], wv[6])\n            + sha256_k[j] + w[j];\n            t2 = SHA256_F1(wv[0]) + MAJ(wv[0], wv[1], wv[2]);\n            wv[7] = wv[6];\n            wv[6] = wv[5];\n            wv[5] = wv[4];\n            wv[4] = wv[3] + t1;\n            wv[3] = wv[2];\n            wv[2] = wv[1];\n            wv[1] = wv[0];\n            wv[0] = t1 + t2;\n        }\n\n        for (j = 0; j &lt; 8; j++) {\n            ctx-&gt;h[j] += wv[j];\n        }\n    }\n}\n\nvoid sha256(const unsigned char *message, unsigned int len, unsigned char *digest)\n{\n    sha256_ctx ctx;\n\n    sha256_init(&amp;ctx);\n    sha256_update(&amp;ctx, message, len);\n    sha256_final(&amp;ctx, digest);\n}\n\nvoid sha256_init(sha256_ctx *ctx)\n{\n    int i;\n    for (i = 0; i &lt; 8; i++) {\n        ctx-&gt;h[i] = sha256_h0[i];\n    }\n\n    ctx-&gt;len = 0;\n    ctx-&gt;tot_len = 0;\n}\n\nvoid sha256_update(sha256_ctx *ctx, const unsigned char *message,\n                   unsigned int len)\n{\n    unsigned int block_nb;\n    unsigned int new_len, rem_len, tmp_len;\n    const unsigned char *shifted_message;\n\n    tmp_len = SHA256_BLOCK_SIZE - ctx-&gt;len;\n    rem_len = len &lt; tmp_len ? len : tmp_len;\n\n    memcpy(&amp;ctx-&gt;block[ctx-&gt;len], message, rem_len);\n\n    if (ctx-&gt;len + len &lt; SHA256_BLOCK_SIZE) {\n        ctx-&gt;len += len;\n        return;\n    }\n\n    new_len = len - rem_len;\n    block_nb = new_len / SHA256_BLOCK_SIZE;\n\n    shifted_message = message + rem_len;\n\n    sha256_transf(ctx, ctx-&gt;block, 1);\n    sha256_transf(ctx, shifted_message, block_nb);\n\n    rem_len = new_len % SHA256_BLOCK_SIZE;\n\n    memcpy(ctx-&gt;block, &amp;shifted_message[block_nb &lt;&lt; 6],\n           rem_len);\n\n    ctx-&gt;len = rem_len;\n    ctx-&gt;tot_len += (block_nb + 1) &lt;&lt; 6;\n}\n\nvoid sha256_final(sha256_ctx *ctx, unsigned char *digest)\n{\n    unsigned int block_nb;\n    unsigned int pm_len;\n    unsigned int len_b;\n\n    int i;\n\n    block_nb = (1 + ((SHA256_BLOCK_SIZE - 9)\n                     &lt; (ctx-&gt;len % SHA256_BLOCK_SIZE)));\n\n    len_b = (ctx-&gt;tot_len + ctx-&gt;len) &lt;&lt; 3;\n    pm_len = block_nb &lt;&lt; 6;\n\n    memset(ctx-&gt;block + ctx-&gt;len, 0, pm_len - ctx-&gt;len);\n    ctx-&gt;block[ctx-&gt;len] = 0x80;\n    UNPACK32(len_b, ctx-&gt;block + pm_len - 4);\n\n    sha256_transf(ctx, ctx-&gt;block, block_nb);\n\n    for (i = 0; i &lt; 8; i++) {\n        UNPACK32(ctx-&gt;h[i], &amp;digest[i &lt;&lt; 2]);\n    }\n}\n\nchar * HMAC_SHA256(char * msg, char * key)\n{\n    size_t blocksize;\n\n    blocksize = 64;\n    char * Key0 = (char *)calloc(blocksize, sizeof(char));\n    if (Key0 == NULL) {\n        return HMAC_SHA256_FAIL_STRING;\n    }\n\n    blocksize = 64;\n    char * Key0_ipad = (char *)calloc(blocksize, sizeof(char));\n    if (Key0_ipad == NULL) {\n        free(Key0);\n        return HMAC_SHA256_FAIL_STRING;\n    }\n\n    blocksize = 64 + strlen(msg);\n    char * Key0_ipad_concat_text = (char *)calloc( blocksize, sizeof(char));\n    if (Key0_ipad_concat_text == NULL) {\n        free(Key0);\n        free(Key0_ipad);\n        return HMAC_SHA256_FAIL_STRING;\n    }\n\n    blocksize = 64;\n    char * Key0_ipad_concat_text_digest = (char *)calloc( blocksize, sizeof(char));\n    if (Key0_ipad_concat_text_digest == NULL) {\n        free(Key0);\n        free(Key0_ipad);\n        free(Key0_ipad_concat_text);\n        return HMAC_SHA256_FAIL_STRING;\n    }\n\n    blocksize = 64;\n    char * Key0_opad = (char *)calloc(blocksize, sizeof(char));\n    if (Key0_opad == NULL) {\n        free(Key0);\n        free(Key0_ipad);\n        free(Key0_ipad_concat_text);\n        free(Key0_ipad_concat_text_digest);\n        return HMAC_SHA256_FAIL_STRING;\n    }\n\n    blocksize = 64 + 32;\n    char * Key0_opad_concat_prev = (char *)calloc(blocksize + 32, sizeof(char));\n    if (Key0_opad_concat_prev == NULL) {\n        free(Key0);\n        free(Key0_ipad);\n        free(Key0_ipad_concat_text);\n        free(Key0_ipad_concat_text_digest);\n        free(Key0_opad);\n        return HMAC_SHA256_FAIL_STRING;\n    }\n\n    blocksize = 64;\n    char * HMAC_SHA256 = (char *)malloc(blocksize/2 * sizeof(char));\n    if (HMAC_SHA256 == NULL) {\n        free(Key0);\n        free(Key0_ipad);\n        free(Key0_ipad_concat_text);\n        free(Key0_ipad_concat_text_digest);\n        free(Key0_opad);\n        free(Key0_opad_concat_prev);\n        return HMAC_SHA256_FAIL_STRING;\n    }\n\n    if (strlen(key) &lt; blocksize) {\n        char * tmp = key;\n        char * tmp2 = Key0;\n        for (int i = 0; i &lt; blocksize; i++) {\n            if (i &lt; strlen(key)) *tmp2++ = *tmp++;\n            else *tmp2++ = 0x00;\n        }\n    }\n    else if (strlen(key) &gt; blocksize) {\n        sha256((unsigned char *)key, strlen(key), (unsigned char *)Key0);\n        for (unsigned char i = strlen(key); i &lt; blocksize; i++) {\n            Key0[i] = 0x00;\n        }\n    }\n\n    for (int i = 0; i &lt; blocksize; i++) {\n        Key0_ipad[i] = Key0[i] ^ 0x36;\n    }\n    for (int i = 0; i &lt; blocksize; i++) {\n        Key0_ipad_concat_text[i] = Key0_ipad[i];\n    }\n    for (int i = blocksize; i &lt; blocksize + strlen(msg); i++) {\n        Key0_ipad_concat_text[i] = msg[i - blocksize];\n    }\n\n    sha256((unsigned char *)Key0_ipad_concat_text, blocksize + (unsigned int)strlen(msg), (unsigned char *)Key0_ipad_concat_text_digest);\n\n    for (int i = 0; i &lt; blocksize; i++) {\n        Key0_opad[i] = Key0[i] ^ 0x5C;\n    }\n\n    for (int i = 0; i &lt; blocksize; i++) {\n        Key0_opad_concat_prev[i] = Key0_opad[i];\n    }\n    for (int i = blocksize; i &lt; blocksize + 32; i++) {\n        Key0_opad_concat_prev[i] = Key0_ipad_concat_text_digest[i - blocksize];\n    }\n\n    sha256((unsigned char *)Key0_opad_concat_prev, blocksize + 32, (unsigned char *)HMAC_SHA256);\n\n    free(Key0);\n    free(Key0_ipad);\n    free(Key0_ipad_concat_text);\n    free(Key0_ipad_concat_text_digest);\n    free(Key0_opad);\n    free(Key0_opad_concat_prev);\n    return HMAC_SHA256;\n}\n\nchar * Base64_Stringify(char * hash, size_t length)\n{\n    size_t no_op = 0;\n    size_t Base64_size;\n    char * Base64;\n    unsigned long tmp = length;\n    if (tmp % 3 == 0) {\n        Base64_size = 4 * tmp / 3;\n        Base64 = (char *)calloc(Base64_size + 1, sizeof(char));\n    }\n    else if (tmp % 3 == 1) {\n        tmp += 2;\n        Base64_size = 4 * tmp / 3;\n        Base64 = (char *)calloc(Base64_size + 1, sizeof(char));\n        Base64[Base64_size - 1] = '=';\n        Base64[Base64_size - 2] = '=';\n        no_op = 2;\n    }\n    else if (tmp % 3 == 2) {\n        tmp += 1;\n        Base64_size = 4 * tmp / 3;\n        Base64 = (char *)calloc(Base64_size + 1, sizeof(char));\n        Base64[Base64_size - 1] = '=';\n        no_op = 1;\n    }\n\n    unsigned int b64_case = 0;\n    size_t j = 0;\n    for (int i = 0; i &lt; Base64_size - no_op; i++) {\n        switch (b64_case) {\n            case 0:\n            {\n                Base64[i] = Base64_Table[(hash[j] &amp; 0xFC) &gt;&gt; 2];\n                j++;\n                b64_case = 1;\n            }\n                break;\n            case 1:\n            {\n                Base64[i] = Base64_Table[((hash[j-1] &amp; 0x03) &lt;&lt; 4) | ((hash[j] &amp; 0xF0) &gt;&gt; 4)];\n                b64_case = 2;\n            }\n                break;\n            case 2:\n            {\n                Base64[i] = Base64_Table[((hash[j] &amp; 0x0F) &lt;&lt; 2) | ((hash[j+1] &amp; 0xC0) &gt;&gt; 6)];\n                j++;\n                b64_case = 3;\n            }\n                break;\n            case 3:\n            {\n                Base64[i] = Base64_Table[(hash[j] &amp; 0x3F)];\n                j++;\n                b64_case = 0;\n            }\n                break;\n\n            default:\n                break;\n        }\n    }\n\n    return Base64;\n}\n\n\nint main()\n{\n    char * HMAC_SHA256_result;\n    char * Base64_Stringify_result;\n\n    HMAC_SHA256_result = HMAC_SHA256(\"test\", \"secret\");\n    Base64_Stringify_result = Base64_Stringify(HMAC_SHA256_result, 32);\n\n    unsigned char arr[32] = { 0 };\n    memcpy(arr, HMAC_SHA256_result, 32);\n\n    for(int i = 0; i &lt; 32; i++) {\n        printf(\"%#02x, \", arr[i]);\n    }\n    printf(\"\\n\\n\");\n\n    for(int i = 0; i &lt; strlen(Base64_Stringify_result); i++) {\n        printf(\"%c\", Base64_Stringify_result[i]);\n    }\n    printf(\"\\n\\n\");\n    return 0;\n}\n</code></pre>\n\n<p>I'm leaving the old main.c for reference. You can also modify the updated main.c functions, e.g. the error codes when calloc fails...</p>\n"
}