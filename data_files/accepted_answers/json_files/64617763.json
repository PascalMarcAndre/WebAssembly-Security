{
    "owner": {
        "reputation": 109497,
        "user_id": 159145,
        "user_type": "registered",
        "accept_rate": 56,
        "profile_image": "https://i.stack.imgur.com/r8ryC.png?s=128&g=1",
        "display_name": "Dai",
        "link": "https://stackoverflow.com/users/159145/dai"
    },
    "is_accepted": true,
    "score": 1,
    "last_activity_date": 1604364069,
    "last_edit_date": 1604364069,
    "creation_date": 1604110079,
    "answer_id": 64617763,
    "question_id": 64617743,
    "content_license": "CC BY-SA 4.0",
    "body": "<p>I note that in the context of ASP.NET Core, ASP.NET MVC (which is older and has been replaced by ASP.NET Core), Razor and Blazor, the term &quot;model&quot; is shorthand for &quot;viewmodel&quot;. Do not confuse it with &quot;Entity model class&quot;, which I believe you're referring to by &quot;data class&quot;.</p>\n<blockquote>\n<p>But do I need to be repeating the same properties for each new model?</p>\n</blockquote>\n<p>Yes (with exceptions, such as when you're <em>composing</em> view-models)</p>\n<blockquote>\n<p>Do the models need to inherit from User data class?</p>\n</blockquote>\n<p>No, don't do that.</p>\n<p>While two or more different types (classes) may share the same members that doesn't mean they represent the <em>same &quot;thing&quot;</em>. In OOP, inheritance should only be used to represent an &quot;is&quot; relationship, not a &quot;has&quot; relationship, and especially not a &quot;<em>I'm-too-lazy-to-have-to-declare-all-of-my-members-again-argh</em>&quot; (though I am very guilty of that last one... ).</p>\n<p>Unfortunately C# does not (yet) support <em>mixins</em>, which is the term used to describe the ability for an object-oriented language to have multiple distinct types with the same members <em>without</em> expressing any kind of actual relationship between those types.</p>\n<p>(With the exception <a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/mixins-with-default-interface-methods\" rel=\"nofollow noreferrer\">that C# 8.0 on .NET Core 3.0 supports _quasi-_mixins with Default Interface Implementation</a>, but it has limitations compared to real mixins, for example I understand you can't use this approach to import operator-overloads, conversion operators, or constructors and I think there's some limitations w.r.t. <code>virtual</code> members too - and I think it doesn't work at all with <code>structs</code> (at least not without boxing, which is bad for performance)).</p>\n<blockquote>\n<p>Is all of this specific to MVC pattern?</p>\n</blockquote>\n<p>It's common to the MVC design in every web framework, really - not just ASP.NET Core or ASP.NET MVC, but MVC frameworks for Python, PHP, Ruby, etc.</p>\n<blockquote>\n<p>How do the model class and the data class relate to each other in the actual implementation?</p>\n</blockquote>\n<ul>\n<li>Given a <em>domain entity</em> in your project (in this case, a &quot;User&quot;):\n<ul>\n<li>The Entity (&quot;data&quot;) class represents the object as a business object, as well as how it's stored in your database.</li>\n<li>Each single View-Model (&quot;model&quot;) class represents a specific <strong>view</strong> of your business domain (which may be read-only or read-write) which is typically a <em>snapshot of a subset of your business domain's object graph</em> as well as containing additional properties for the page itself (such as the page <code>&lt;title&gt;</code>, the currently logged-in user's details, etc).\n<ul>\n<li>Note that a single domain entity class can have more than one view-model class to represent it (see below). And similarly, a view-model can represent more than one domain entity object (or none at all).</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>For example:</p>\n<ul>\n<li>Given a <code>class User</code> (your entity class):\n<ul>\n<li>A &quot;User List&quot; page will have <code>class UserListPageViewModel</code> with an <code>IReadOnlyList&lt;User&gt;</code> property.</li>\n<li>An &quot;Edit User&quot; page will have a <code>class EditUserPageViewModel</code> with with properties for each editable user property/column/attribute.\n<ul>\n<li>But it <strong>must not</strong> expose the <code>User</code> class for model-binding, because then an attacker could send a fake <code>POST</code> form request that instructs the model-binder to overwrite the <code>Password</code> field, for example.</li>\n</ul>\n</li>\n<li>A &quot;Welcome page&quot; view-model may also contain a <code>public User CurrentUser { get; }</code> property which contains a loaded <code>User</code> instance with information that a &quot;layout&quot; <code>.cshtml</code> file (aka <code>.master</code> &quot;master page&quot; in Aspx, or any kind of common HTML template, etc) will use to populate a &quot;Welcome John Doe&quot; area, etc.</li>\n</ul>\n</li>\n</ul>\n"
}