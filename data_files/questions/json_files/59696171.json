{
    "tags": [
        "asp.net-identity",
        "blazor",
        "blazor-client-side"
    ],
    "owner": {
        "reputation": 2601,
        "user_id": 2838509,
        "user_type": "registered",
        "accept_rate": 63,
        "profile_image": "https://www.gravatar.com/avatar/ddc514bdff431b6db641bba4d96d7658?s=128&d=identicon&r=PG&f=1",
        "display_name": "NPadrutt",
        "link": "https://stackoverflow.com/users/2838509/npadrutt"
    },
    "is_answered": true,
    "view_count": 73,
    "accepted_answer_id": 59698331,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1578774007,
    "creation_date": 1578759037,
    "last_edit_date": 1578763620,
    "question_id": 59696171,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/59696171/signin-returns-successfull-but-user-is-not",
    "title": "SignIn returns successfull but User is not",
    "body": "<p>I have an Blazor WASM application. I use the Identity Framework for login with: </p>\n\n<pre><code>SignInResult signInResult = await signInManager&lt;ApplicationUser&gt;.PasswordSignInAsync(parameters.UserName, parameters.Password, parameters.RememberMe, true);\n</code></pre>\n\n<p>The <code>signInResult</code> is always <code>Succeeded</code>.</p>\n\n<p>In the StateProvider in WebAssembly I get a UserInfo object which among other things tells if the user is Authenticated:</p>\n\n<pre><code>    [HttpGet]\n    public UserInfoDto UserInfo()\n    {\n        return BuildUserInfo();\n    }\n\n    private UserInfoDto BuildUserInfo()\n    {\n        var userInfo = new UserInfoDto\n        {\n            IsAuthenticated = User.Identity.IsAuthenticated,\n            UserName = User.Identity.Name\n        };\n\n        foreach (var claim in User.Claims)\n        {\n            userInfo.ExposedClaims.Add(claim.Type, claim.Value);\n        }\n\n        if (userInfo.IsAuthenticated)\n        {\n            userInfo.Id = Guid.Parse(identityService.GetUserId(User));\n        }\n\n        return userInfo;\n    }\n</code></pre>\n\n<p>Here <code>User.Identity.IsAuthenticated</code> is always false. I also checked it right after the PasswordSignInAsync but there it is the same as well.</p>\n\n<p>My startup is setup this way:</p>\n\n<pre><code>services.AddIdentity&lt;ApplicationUser, ApplicationIdentityRole&gt;()\n        .AddEntityFrameworkStores&lt;SupportToolContext&gt;()\n        .AddDefaultTokenProviders();\n\nservices.Configure&lt;IdentityOptions&gt;(options =&gt;\n        {\n            // Password settings\n            options.Password.RequireDigit = false;\n            options.Password.RequiredLength = MIN_PASSWORD_LENGTH;\n            options.Password.RequireNonAlphanumeric = false;\n            options.Password.RequireUppercase = false;\n            options.Password.RequireLowercase = false;\n\n            // Lockout settings\n            options.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(LOCKOUT_DURATION);\n            options.Lockout.MaxFailedAccessAttempts = MAX_TRIES_BEFORE_LOCKOUT;\n            options.Lockout.AllowedForNewUsers = true;\n\n            // Email Settings\n            options.User.RequireUniqueEmail = true;\n            options.SignIn.RequireConfirmedEmail = true;\n        });\n\n// Configure LifeSpan of Identity email tokens\nservices.Configure&lt;DataProtectionTokenProviderOptions&gt;(options =&gt;\n        {\n            options.TokenLifespan = TimeSpan.FromDays(3);\n        });\n\nservices.ConfigureApplicationCookie(options =&gt;\n        {\n            options.Cookie.HttpOnly = false;\n            options.Events = new CookieAuthenticationEvents\n                             {\n                                 OnRedirectToLogin = context =&gt;\n                                                     {\n                                                         context.Response.StatusCode = UNAUTHORIZED_STATUS_CODE;\n                                                         return Task.CompletedTask;\n                                                     }\n                             };\n        });\n</code></pre>\n\n<p>And the Configure method contains:</p>\n\n<pre><code>app.UseAuthentication();\napp.UseAuthorization();\n</code></pre>\n\n<p>AuthenticationStateProvider:</p>\n\n<p>public class IdentityAuthenticationStateProvider : AuthenticationStateProvider\n    {\n        private UserInfoDto userInfoCache;\n        private readonly IServiceProvider serviceProvider;</p>\n\n<pre><code>    public IdentityAuthenticationStateProvider(IServiceProvider serviceProvider)\n    {\n        this.serviceProvider = serviceProvider;\n    }\n\n    ..\n\n    private async Task&lt;UserInfoDto&gt; GetUserInfoAsync()\n    {\n        var authorizeApi = serviceProvider.GetRequiredService&lt;IAuthorizeApi&gt;();\n\n        if (userInfoCache != null &amp;&amp; userInfoCache.IsAuthenticated) return userInfoCache;\n        userInfoCache = await authorizeApi.GetUserInfoAsync();\n\n        return userInfoCache;\n    }\n\n    public override async Task&lt;AuthenticationState&gt; GetAuthenticationStateAsync()\n    {\n        var identity = new ClaimsIdentity();\n        try\n        {\n            UserInfoDto userInfo = await GetUserInfoAsync();\n            if (userInfo.IsAuthenticated)\n            {\n                IEnumerable&lt;Claim&gt; claims = new[] {new Claim(ClaimTypes.Name, userInfoCache.UserName)}.Concat(\n                    userInfoCache.ExposedClaims.Select(c =&gt; new Claim(c.Key, c.Value)));\n                identity = new ClaimsIdentity(claims, \"Server authentication\");\n            }\n        }\n        catch (HttpRequestException ex)\n        {\n            Console.WriteLine(\"Request failed:\" + ex);\n        }\n\n        return new AuthenticationState(new ClaimsPrincipal(identity));\n    }\n}\n</code></pre>\n\n<p>In general the whole process is identical to this example: <a href=\"https://github.com/stavroskasidis/BlazorWithIdentity\" rel=\"nofollow noreferrer\">https://github.com/stavroskasidis/BlazorWithIdentity</a>\n(which stopped working locally as well)</p>\n\n<p>What confuses me is that it worked before and still does on the server and it doesn't work locally if I checkout that history at the point deployed to the server. What do I miss? </p>\n"
}