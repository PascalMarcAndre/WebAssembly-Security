{
    "tags": [
        "asp.net-core",
        "authorization",
        "policy"
    ],
    "owner": {
        "reputation": 339,
        "user_id": 3178347,
        "user_type": "registered",
        "accept_rate": 0,
        "profile_image": "https://www.gravatar.com/avatar/24e53f817e51cf22f4f0deb17559604b?s=128&d=identicon&r=PG&f=1",
        "display_name": "Alex",
        "link": "https://stackoverflow.com/users/3178347/alex"
    },
    "is_answered": false,
    "view_count": 488,
    "answer_count": 0,
    "score": 0,
    "last_activity_date": 1594636261,
    "creation_date": 1594366807,
    "last_edit_date": 1594636261,
    "question_id": 62829453,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/62829453/context-user-identity-name-not-available-in-blazor-asp-net-core-hosted",
    "title": "context.User.Identity.Name not available in Blazor ASP.NET Core hosted",
    "body": "<p>I created BlazorApp1, a Blazor Webassembly app with the option ASP.NET Core hosted. This created three projects: BlazorApp1.Client, BlazorApp1.Server and BlazorApp1.Shared. I created the custom authorization policy as described in <a href=\"https://chrissainty.com/securing-your-blazor-apps-configuring-policy-based-authorization-with-blazor/\" rel=\"nofollow noreferrer\">Chris Sainty's article about policy-based authorization</a> by adding Policies.cs to BlazorApp1.Shared:</p>\n<pre><code>using Microsoft.AspNetCore.Authorization;\nusing System.Security.Claims;\nusing System.Threading.Tasks;\n\nnamespace BlazorApp1.Shared\n{\n    public class CompanyDomainRequirement : IAuthorizationRequirement\n    {\n        public string CompanyDomain { get; }\n\n        public CompanyDomainRequirement(string companyDomain)\n        {\n            CompanyDomain = companyDomain;\n        }\n    }\n\n    public class CompanyDomainHandler : AuthorizationHandler&lt;CompanyDomainRequirement&gt;\n    {\n        protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, CompanyDomainRequirement requirement)\n        {\n            if (!context.User.HasClaim(c =&gt; c.Type == ClaimTypes.Email))\n            {\n                return Task.CompletedTask;\n            }\n\n            var emailAddress = context.User.FindFirst(c =&gt; c.Type == ClaimTypes.Email).Value;\n\n            if (emailAddress.EndsWith(requirement.CompanyDomain))\n            {\n                context.Succeed(requirement);\n            }\n\n            return Task.CompletedTask;\n        }\n    }\n}\n</code></pre>\n<p>I added this custom policy to BlazorApp1.Server.Startup.cs:</p>\n<pre><code>public void ConfigureServices(IServiceCollection services)\n{\n    services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;\n        options.UseSqlServer(\n            Configuration.GetConnectionString(&quot;DefaultConnection&quot;)));\n\n    services.AddDefaultIdentity&lt;ApplicationUser&gt;(options =&gt; options.SignIn.RequireConfirmedAccount = true)\n        .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;();\n\n    services.AddIdentityServer()\n        .AddApiAuthorization&lt;ApplicationUser, ApplicationDbContext&gt;();\n\n    services.AddAuthentication()\n        .AddIdentityServerJwt();\n\n    services.AddAuthorization(config =&gt;\n    {\n        config.AddPolicy(&quot;IsCompanyUser&quot;, policy =&gt;\n            policy.Requirements.Add(new CompanyDomainRequirement(&quot;newco.com&quot;)));\n    });\n\n    services.AddSingleton&lt;IAuthorizationHandler, CompanyDomainHandler&gt;();\n\n    services.AddControllersWithViews();\n    services.AddRazorPages();\n}\n</code></pre>\n<p>In BlazorApp1.Server.WeatherForecastController, I added this policy to the Authorize attribute:</p>\n<pre><code>using BlazorApp1.Shared;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace BlazorApp1.Server.Controllers\n{\n    [Authorize(Policy = &quot;IsCompanyUser&quot;)]\n    [ApiController]\n    [Route(&quot;[controller]&quot;)]\n    public class WeatherForecastController : ControllerBase\n    {\n        private static readonly string[] Summaries = new[]\n        {\n            &quot;Freezing&quot;, &quot;Bracing&quot;, &quot;Chilly&quot;, &quot;Cool&quot;, &quot;Mild&quot;, &quot;Warm&quot;, &quot;Balmy&quot;, &quot;Hot&quot;, &quot;Sweltering&quot;, &quot;Scorching&quot;\n        };\n\n        private readonly ILogger&lt;WeatherForecastController&gt; logger;\n\n        public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger)\n        {\n            this.logger = logger;\n        }\n\n        [HttpGet]\n        public IEnumerable&lt;WeatherForecast&gt; Get()\n        {\n            var rng = new Random();\n            return Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast\n            {\n                Date = DateTime.Now.AddDays(index),\n                TemperatureC = rng.Next(-20, 55),\n                Summary = Summaries[rng.Next(Summaries.Length)]\n            })\n            .ToArray();\n        }\n    }\n}\n</code></pre>\n<p>However, when I set a break point at CompanyDomainHandler.HandleRequirementAsync run the app, log-in, and click on Fetch Data, and watch context.User.Identity.Name  at the break point, I see that it is null and context.User.Identity.Claims does not have the name or email of the authenticated user.</p>\n<p><a href=\"https://i.stack.imgur.com/cllqw.jpg\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/cllqw.jpg\" alt=\"Debugger showing context.User in CompanyDomainHandler.HandleRequirementAsync\" /></a></p>\n<p>However, in the client, LoginDisplay.razor correctly displays context.User.Identity.Name:</p>\n<pre><code>@using Microsoft.AspNetCore.Components.Authorization\n@using Microsoft.AspNetCore.Components.WebAssembly.Authentication\n\n@inject NavigationManager Navigation\n@inject SignOutSessionStateManager SignOutManager\n\n&lt;AuthorizeView&gt;\n    &lt;Authorized&gt;\n        &lt;a href=&quot;authentication/profile&quot;&gt;Hello, @context.User.Identity.Name!&lt;/a&gt;\n        &lt;button class=&quot;nav-link btn btn-link&quot; @onclick=&quot;BeginSignOut&quot;&gt;Log out&lt;/button&gt;\n    &lt;/Authorized&gt;\n    &lt;NotAuthorized&gt;\n        &lt;a href=&quot;authentication/register&quot;&gt;Register&lt;/a&gt;\n        &lt;a href=&quot;authentication/login&quot;&gt;Log in&lt;/a&gt;\n    &lt;/NotAuthorized&gt;\n&lt;/AuthorizeView&gt;\n\n@code{\n    private async Task BeginSignOut(MouseEventArgs args)\n    {\n        await SignOutManager.SetSignOutState();\n        Navigation.NavigateTo(&quot;authentication/logout&quot;);\n    }\n}\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/o5PkF.jpg\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/o5PkF.jpg\" alt=\"LoginDisplay.razor displaying context.User.Identity.Name\" /></a></p>\n<p>How can I have context.User.Identity.Name to be defined in CompanyDomainHandler.HandleRequirementAsync (the custom policy)?</p>\n"
}