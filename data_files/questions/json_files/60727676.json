{
    "tags": [
        "c#",
        "asp.net-core",
        "cors",
        "azure-active-directory",
        "blazor-client-side"
    ],
    "owner": {
        "reputation": 1950,
        "user_id": 1121245,
        "user_type": "registered",
        "accept_rate": 80,
        "profile_image": "https://www.gravatar.com/avatar/b9b01fb3b20f21cebcc7784fb4809abd?s=128&d=identicon&r=PG",
        "display_name": "Michele mpp Marostica",
        "link": "https://stackoverflow.com/users/1121245/michele-mpp-marostica"
    },
    "is_answered": true,
    "view_count": 787,
    "accepted_answer_id": 60742802,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1584610190,
    "creation_date": 1584467384,
    "last_edit_date": 1584468180,
    "question_id": 60727676,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/60727676/blazor-webassembly-with-azuread",
    "title": "Blazor WebAssembly with AzureAD",
    "body": "<p>I need to let the user of the WebAssembly app I'm developing to login through AzureAD.\nI'm using the repo <a href=\"https://github.com/AzureAD/microsoft-identity-web.git\" rel=\"nofollow noreferrer\">Microsoft.Identity.Web</a> (and UI).</p>\n\n<p>Here what I did so far:</p>\n\n<p>appsetting.json</p>\n\n<pre><code> \"AzureAd\": {\n    \"Instance\": \"https://login.microsoftonline.com\",\n    \"Domain\": \"xxx\",\n    \"TenantId\": \"xxx\",\n    \"ClientId\": \"xxx\",\n    \"CallbackPath\": \"/signin-oidc\",\n    \"SignedOutCallbackPath \": \"/signout-callback-oidc\",\n\n    \"ClientSecret\": \"xxx\"\n  },\n</code></pre>\n\n<p>Server side startup.cs</p>\n\n<pre><code>public class Startup\n{\n    public IConfiguration Configuration { get; }\n    public Startup(IConfiguration configuration)\n    {\n        Configuration = configuration;\n    }\n\n    // This method gets called by the runtime. Use this method to add services to the container.\n    // For more information on how to configure your application, visit https://go.microsoft.com/fwlink/?LinkID=398940\n    public void ConfigureServices(IServiceCollection services)\n    {\n        services.AddMvc();\n        services.AddResponseCompression(opts =&gt;\n        {\n            opts.MimeTypes = ResponseCompressionDefaults.MimeTypes.Concat(\n                new[] { \"application/octet-stream\" });\n        });\n\n        // Sign-in users with the Microsoft identity platform\n        //services.AddSignIn(Configuration);\n        services.AddAuthentication(OpenIdConnectDefaults.AuthenticationScheme)\n                .AddSignIn(\"AzureAD\", Configuration, options =&gt; Configuration.Bind(\"AzureAD\", options));\n\n        // Looks like I need this to have the login UI\n        services.AddControllersWithViews(options =&gt;\n        {\n            var policy = new AuthorizationPolicyBuilder()\n                .RequireAuthenticatedUser()\n                .Build();\n            options.Filters.Add(new AuthorizeFilter(policy));\n        }).AddMicrosoftIdentityUI();\n        services.AddRazorPages();\n    }\n\n    // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n    {\n        app.UseResponseCompression();\n\n        if (env.IsDevelopment())\n        {\n            app.UseDeveloperExceptionPage();\n            app.UseBlazorDebugging();\n        }\n\n        app.UseCors();\n\n        app.UseStaticFiles();\n        app.UseClientSideBlazorFiles&lt;Client.Program&gt;();\n\n        app.UseRouting();\n        app.UseAuthentication();\n        app.UseAuthorization();\n\n        app.UseEndpoints(endpoints =&gt;\n        {\n            endpoints.MapDefaultControllerRoute();\n            endpoints.MapFallbackToClientSideBlazor&lt;Client.Program&gt;(\"index.html\");\n        });\n    }\n}\n</code></pre>\n\n<p>UserController.cs</p>\n\n<pre><code>[ApiController]\n[Route(\"api/[controller]\")]\npublic class UserController : ControllerBase\n{\n    [HttpGet]\n    public AppUser Get()\n    {\n        AppUser toReturn = new AppUser();\n        if (this.User.Identity.IsAuthenticated)\n        {\n            toReturn.UserName = this.User.Identity.Name;\n        }\n        else\n        {\n            toReturn.UserName = \"\"; // Not logged in\n        }\n        return toReturn;\n    }\n}\n</code></pre>\n\n<p>Client program.cs</p>\n\n<pre><code>public class Program\n{\n    public static async Task Main(string[] args)\n    {\n        var builder = WebAssemblyHostBuilder.CreateDefault(args);\n\n        // Use our CustomAuthenticationProvider as the \n        // AuthenticationStateProvider\n        builder.Services.AddScoped&lt;AuthenticationStateProvider, CustomAuthenticationProvider&gt;();\n\n        // Add Authentication support\n        builder.Services.AddOptions();\n        builder.Services.AddAuthorizationCore();\n\n        builder.RootComponents.Add&lt;App&gt;(\"app\");\n        await builder.Build().RunAsync();\n    }\n}\n\npublic class CustomAuthenticationProvider : AuthenticationStateProvider\n{\n    private readonly HttpClient _httpClient;\n    public CustomAuthenticationProvider(HttpClient httpClient)\n    {\n        _httpClient = httpClient;\n    }\n    public override async Task&lt;AuthenticationState&gt; GetAuthenticationStateAsync()\n    {\n        ClaimsPrincipal user;\n\n        // Call the GetUser method to get the status\n        // This only sets things like the AuthorizeView\n        // and the AuthenticationState CascadingParameter\n        var result = await _httpClient.GetJsonAsync&lt;AppUser&gt;(\"api/user\");\n\n        // Was a UserName returned?\n        if (result.UserName != \"\")\n        {\n            // Create a ClaimsPrincipal for the user\n            var identity = new ClaimsIdentity(new[]\n            {\n               new Claim(ClaimTypes.Name, result.UserName),\n            }, \"AzureAdAuth\");\n            user = new ClaimsPrincipal(identity);\n        }\n        else\n        {\n            user = new ClaimsPrincipal(); // Not logged in\n        }\n        return await Task.FromResult(new AuthenticationState(user));\n    }\n}\n</code></pre>\n\n<p>App.razor</p>\n\n<pre class=\"lang-html prettyprint-override\"><code>&lt;Router AppAssembly=\"@typeof(Program).Assembly\"&gt;\n    &lt;Found Context=\"routeData\"&gt;\n        &lt;AuthorizeRouteView RouteData=\"@routeData\" DefaultLayout=\"@typeof(MainLayout)\" /&gt;\n    &lt;/Found&gt;\n    &lt;NotFound&gt;\n        &lt;CascadingAuthenticationState&gt;\n            &lt;LayoutView Layout=\"@typeof(MainLayout)\"&gt;\n                &lt;p&gt;Sorry, there's nothing at this address.&lt;/p&gt;\n            &lt;/LayoutView&gt;\n        &lt;/CascadingAuthenticationState&gt;\n    &lt;/NotFound&gt;\n&lt;/Router&gt;\n</code></pre>\n\n<p>Login.razor</p>\n\n<pre class=\"lang-html prettyprint-override\"><code>&lt;AuthorizeView&gt;\n    &lt;Authorized&gt;\n        &lt;h6&gt;Hello, @context.User.Identity.Name! &lt;/h6&gt;\n        &lt;a href=\"MicrosoftIdentity/Account/SignOut\"&gt;[Log out]&lt;/a&gt;\n    &lt;/Authorized&gt;\n    &lt;NotAuthorized&gt;\n        &lt;a href=\"MicrosoftIdentity/Account/SignIn\"&gt;[Log in]&lt;/a&gt;\n    &lt;/NotAuthorized&gt;\n&lt;/AuthorizeView&gt;\n</code></pre>\n\n<p>I can login if I manually enter the route <a href=\"https://localhost:xxxxx/MicrosoftIdentity/Account/SignIn\" rel=\"nofollow noreferrer\">https://localhost:xxxxx/MicrosoftIdentity/Account/SignIn</a>. And when the user is logged in, everything works as expected.</p>\n\n<p>I have the following exception when the user is not logged in, and blazor try to load the <code>&lt;AuthorizeView /&gt;</code> part of the layout:</p>\n\n<pre><code>Access to fetch at 'https://login.microsoftonline.com/xxx/oauth2/v2.0/authorize?client_id=xxx&amp;redirect_uri=https%3A%2F%2Flocalhost%3A44316%2Fsignin-oidc&amp;response_type=code%20id_token&amp;scope=openid%20profile%20offline_access%xxx%2Fuser_impersonation&amp;response_mode=form_post&amp;nonce=xxx&amp;x-client-SKU=ID_NETSTANDARD2_0&amp;x-client-ver=5.5.0.0' (redirected from 'https://localhost:44316/api/user') from origin 'https://localhost:44316' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.\n</code></pre>\n\n<p>I'm trying to enable CORS on the server side as explained <a href=\"https://docs.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-3.1\" rel=\"nofollow noreferrer\">here</a>, but I had no success yet.\nWhat am I missing?</p>\n"
}