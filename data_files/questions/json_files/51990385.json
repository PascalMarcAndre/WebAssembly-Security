{
    "tags": [
        "cross-platform",
        "sandbox",
        "webassembly",
        "scripting-language",
        "seccomp"
    ],
    "owner": {
        "reputation": 3961,
        "user_id": 1021959,
        "user_type": "registered",
        "accept_rate": 83,
        "profile_image": "https://i.stack.imgur.com/PaP06.png?s=128&g=1",
        "display_name": "Bernard",
        "link": "https://stackoverflow.com/users/1021959/bernard"
    },
    "is_answered": true,
    "view_count": 194,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1535046746,
    "creation_date": 1535041706,
    "question_id": 51990385,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/51990385/how-to-execute-an-untrusted-function-efficiently-in-a-cross-platform-way",
    "title": "How to execute an untrusted function efficiently in a cross-platform way?",
    "body": "<p>I am writing an open source cross-platform application written in C++ that targets Windows, Mac, and Linux on x86 CPUs.  The application produces a stream of data (integers) that needs to be validated, and my application will perform actions depending on the validation result.  There are multiple validators, which we shall call \"modules\", and they can be swapped out for one another.</p>\n\n<p>Anybody can write and share modules with other users, so my application has to ensure that maliciously-written modules cannot harm the user in any way (perhaps except via high CPU usage, in which case my application should be able to kill the module after some amount of time - this can be done by using a surrogate process).  Furthermore, the stream of data is being sent at a high rate (up to 100kB/s).</p>\n\n<p>Fortunately, the code in these modules are usually simple arithmetic operations on data in the stream (usually processing each incoming integer in constant time), and they do not need to make any system calls (not even heap allocation).</p>\n\n<hr>\n\n<p>I've considered the following possibilities (all of them with some drawbacks):</p>\n\n<ul>\n<li><p><strong>Kernel-based sandboxing</strong></p>\n\n<ul>\n<li><p>On Linux, we can use secure computing (<a href=\"https://en.wikipedia.org/wiki/Seccomp\" rel=\"nofollow noreferrer\">seccomp</a>), which prevents a process from making any system calls except for reading and writing with already-open file destriptors.  Module creators would write their modules as a single function that takes in input and output file descriptors (in a language like C or C++) and compile it into a shared object, then distribute that shared object.</p>\n\n<p>My application will probably prepare input and output file descriptors, then <code>fork()</code> itself or <code>exec()</code> a surrogate process, and this child process uses <code>dlopen()</code> and <code>dlsym()</code> to get a pointer to the untrusted function.  Then strict secure computing mode will be enabled, before executing the untrusted function.</p>\n\n<p>Drawbacks: There's the problem that <code>dlopen()</code> will actually run the constructor function from the shared library.  This would have to be properly sandboxed as well, and I can't think of a way to do so.  Also, of course, this thing will only work on Linux.  As far as I know, there is no way to ban WinNT system calls on Windows, so a similar solution on Windows won't be very secure.</p></li>\n</ul></li>\n<li><p><strong>Application-level sandboxing</strong></p>\n\n<ul>\n<li><p>[[ Any form of application-level sandboxing means that we cannot run untrusted machine code of any form.  An untrusted function can overwrite its return value or data outside its call stack, thereby compromising the whole application (and effectively acquiring any permissions that the original application had). ]]</p></li>\n<li><p>Make modules use a simple scripting language that does not support any system calls - just pure arithmetic operations and perhaps the ability to read an input stream.   My application would contain an interpreter for this language.</p>\n\n<p>Drawbacks: Unfortunately I have not found this scripting language.  Many scripting languages have extensive functionalities (e.g. Python) and a sandbox (e.g. <a href=\"https://pypy.readthedocs.io/en/latest/sandbox.html\" rel=\"nofollow noreferrer\">PyPy's sandbox</a>) simply filters OS system calls.  I would be shipping a lot of useless interpreter code with my application, and it arguably is more prone to security issues due to bugs in the intepreter than a language with simply no functionality to do things other than simple calculations and control flow instructions (basically a function that does not make any system calls).  Furthermore, marshalling the data between C++ (machine code) and the scripting language is usually a slow process.</p></li>\n<li><p>Distribute modules with a 'safe' compiled language that again does not support any system calls.  My application would contain a JIT for this language.<br>\nMarshalling won't be necessary because my application would call into the JITted machine code of the untrusted module, so performance across this boundary should be fast.  The untrusted module now won't be able to corrupt the stack, attempt return-oriented programming, or perform any other malicious actions, due to the language restrictions and checks of the 'safe' language.  WebAssembly is the first and only language that comes to mind (if it can be called a language).  (As far as I can tell, WebAssembly seems to provide the security guarantees for my use case, right?)</p>\n\n<p>Drawbacks: The existing implementations of WebAssembly seem to be all browser-based, so I would have to steal an implementation from an open source browser.  This does seem like a lot of work, considering that I would have to uncouple it from all the JavaScript and other browser bits.  However, a <a href=\"https://github.com/WebAssembly/wasm-jit-prototype\" rel=\"nofollow noreferrer\">standalone WebAssembly JIT</a> based on LLVM seems to be under development.</p></li>\n</ul></li>\n</ul>\n\n<hr>\n\n<p>Question:</p>\n\n<p><strong>What is the best way to execute an untrusted function efficiently that works on Windows, Mac, and Linux?</strong></p>\n\n<p>Right now, I think that the scripting language way would probably be the safest, and be the easiest for module writers.  But for a more efficient solution, WebAssembly is probably better.  Am I right, or are there better or easier solutions that I have not thought of?</p>\n\n<hr>\n\n<p><em>(Remark: I think several pairs of tags used in this question have never been seen together before!)</em></p>\n"
}