{
    "tags": [
        "jwt",
        "openid-connect",
        "access-token",
        "blazor",
        "blazor-webassembly"
    ],
    "owner": {
        "reputation": 108,
        "user_id": 11080892,
        "user_type": "registered",
        "profile_image": "https://lh4.googleusercontent.com/--FtsbDs1DdA/AAAAAAAAAAI/AAAAAAAAABc/kpnXGBoIXwk/photo.jpg?sz=128",
        "display_name": "Jeff Bacon",
        "link": "https://stackoverflow.com/users/11080892/jeff-bacon"
    },
    "is_answered": true,
    "view_count": 899,
    "accepted_answer_id": 63136893,
    "answer_count": 1,
    "score": 2,
    "last_activity_date": 1595955224,
    "creation_date": 1595538930,
    "last_edit_date": 1595601763,
    "question_id": 63063237,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/63063237/how-do-i-get-the-id-token-in-blazor-webassembly-after-authenticating-with-openid",
    "title": "How do I get the id_token in Blazor WebAssembly after authenticating with OpenId (Cognito)?",
    "body": "<p>I've got a .Net Core 3.1 WebApi backend.</p>\n<p>I've got a Blazor WebAssembly front-end.</p>\n<p>I'm trying to login on the front-end (works) to AWS Cognito (setup as an OpenId provider) and then pass a Bearer token (JWT) to my backend API on each request so that the backend API can access AWS resources using temporary credentials (CognitoAWSCredentials).</p>\n<p>I am able to pass a Bearer token on each request from my Blazor front-end to the backend, however the only token I can find to access in Blazor is the Access Token. I need the ID Token in order to allow the backend to generate credentials on my user's behalf.</p>\n<p>In my Blazor code I have successfully registered a custom AuthorizationMessageHandler which gets invokes on each HttpClient's SendAsync when accessing my API:</p>\n<pre class=\"lang-cs prettyprint-override\"><code>protected override async Task&lt;HttpResponseMessage&gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\n{\n    HttpRequestHeaders headers = request?.Headers;\n    AuthenticationHeaderValue authHeader = headers?.Authorization;\n    if (headers is object &amp;&amp; authHeader is null)\n    {\n        AccessTokenResult result = await TokenProvider.RequestAccessToken();\n        if (result.TryGetToken(out AccessToken token))\n        {\n            authHeader = new AuthenticationHeaderValue(&quot;Bearer&quot;, token.Value);\n            request.Headers.Authorization = authHeader;\n        }\n        logger.LogObjectDebug(request);\n    }\n    return await base.SendAsync(request, cancellationToken);\n}\n</code></pre>\n<p>This adds the <strong>Access Token</strong> and the backend picks up the token and validates it fine.\nHowever, to create the CognitoAWSCredentials for AWS services to use for privileges, I need the <em>ID Token</em>.</p>\n<p><strong>I cannot find any way to access the ID Token within Blazor.</strong></p>\n<p>If I access my backend WebApi directly, it will properly forward me to Cognito to login and then return back. When it does, the HttpContext contains the &quot;id_token&quot;. This can then be used to create the CognitoAWSCredentials I need.</p>\n<p>The missing link is how to access the ID Token in Blazor so I can put that as the Authorization HTTP header's Bearer token instead of the Access Token.</p>\n<p>adding a bit more code context ....</p>\n<h2>Program.cs:Main</h2>\n<pre class=\"lang-cs prettyprint-override\"><code>string CognitoMetadataAddress = $&quot;{settings.Cognito.Authority?.TrimEnd('/')}/.well-known/openid-configuration&quot;;\n\nbuilder.Services.AddOidcAuthentication&lt;RemoteAuthenticationState, CustomUserAccount&gt;(options =&gt;\n                {\n                    options.ProviderOptions.Authority = settings.Cognito.Authority;\n                    options.ProviderOptions.MetadataUrl = CognitoMetadataAddress;\n                    options.ProviderOptions.ClientId = settings.Cognito.ClientId;\n                    options.ProviderOptions.RedirectUri = $&quot;{builder.HostEnvironment.BaseAddress.TrimEnd('/')}/authentication/login-callback&quot;;\n                    options.ProviderOptions.ResponseType = OpenIdConnectResponseType.Code;\n                })\n                .AddAccountClaimsPrincipalFactory&lt;RemoteAuthenticationState, CustomUserAccount, CustomAccountFactory&gt;()\n;\n\nbuilder.Services.AddOptions();\nbuilder.Services.AddAuthorizationCore();\n\nstring APIBaseUrl = builder.Configuration.GetSection(&quot;Deployment&quot;)[&quot;APIBaseUrl&quot;];\nbuilder.Services.AddSingleton&lt;CustomAuthorizationMessageHandler&gt;();\n\nbuilder.Services.AddHttpClient(settings.HttpClientName, client =&gt; \n                {\n                    client.BaseAddress = new Uri(APIBaseUrl);\n                })\n                .AddHttpMessageHandler&lt;CustomAuthorizationMessageHandler&gt;()\n                ;\n</code></pre>\n<h2>Sending the http request (minor changes from the Blazor sample code)...</h2>\n<pre class=\"lang-cs prettyprint-override\"><code>HttpRequestMessage requestMessage = new HttpRequestMessage()\n{\n    Method = new HttpMethod(method),\n    RequestUri = new Uri(uri),\n    Content = string.IsNullOrEmpty(requestBody) ? null : new StringContent(requestBody)\n};\n\nforeach (RequestHeader header in requestHeaders)\n{\n    // StringContent automatically adds its own Content-Type header with default value &quot;text/plain&quot;\n    // If the developer is trying to specify a content type explicitly, we need to replace the default value,\n    // rather than adding a second Content-Type header.\n    if (header.Name.Equals(&quot;Content-Type&quot;, StringComparison.OrdinalIgnoreCase) &amp;&amp; requestMessage.Content != null)\n    {\n        requestMessage.Content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue(header.Value);\n        continue;\n    }\n\n    if (!requestMessage.Headers.TryAddWithoutValidation(header.Name, header.Value))\n    {\n        requestMessage.Content?.Headers.TryAddWithoutValidation(header.Name, header.Value);\n    }\n}\n\nHttpClient Http = HttpClientFactory.CreateClient(Settings.HttpClientName);\nHttpResponseMessage response = await Http.SendAsync(requestMessage);\n</code></pre>\n<p>When the OpenIdConnect middleware tries to authorize with Cognito, it calls:</p>\n<pre><code>https://&lt;DOMAIN&gt;/oauth2/authorize?client_id=&lt;CLIENT-ID&gt;&amp;redirect_uri=https%3A%2F%2Flocalhost%3A44356%2Fauthentication%2Flogin-callback&amp;response_type=code&amp;scope=openid%20profile&amp;state=&lt;HIDDEN&gt;&amp;code_challenge=&lt;HIDDEN&gt;&amp;code_challenge_method=S256&amp;response_mode=query\n</code></pre>\n<p><em>(HIDDEN: inserted by me for some values that might be sensitive)</em></p>\n<ul>\n<li>Cognito Docs on /oauth2/authorize: <a href=\"https://docs.aws.amazon.com/cognito/latest/developerguide/authorization-endpoint.html\" rel=\"nofollow noreferrer\">https://docs.aws.amazon.com/cognito/latest/developerguide/authorization-endpoint.html</a></li>\n</ul>\n<p><em>An ID token is only returned if <strong>openid</strong> scope is requested. The access token can be only used against Amazon Cognito User Pools if aws.cognito.signin.user.admin scope is requested.</em></p>\n<p>Since my normal users are not admins, I'm not requesting the admin scope.</p>\n<p>So according to the docs, Cognito should be returning an ID token.\nWhen I print out the claims for the ClaimsPrincipal created by the OIDC middleware in Blazor the token_use is <code>id</code>:</p>\n<pre><code>  {\n    &quot;Type&quot;: &quot;token_use&quot;,\n    &quot;Value&quot;: &quot;id&quot;,\n    &quot;ValueType&quot;: &quot;http://www.w3.org/2001/XMLSchema#string&quot;,\n    &quot;Subject&quot;: null,\n    &quot;Properties&quot;: {},\n    &quot;OriginalIssuer&quot;: &quot;LOCAL AUTHORITY&quot;,\n    &quot;Issuer&quot;: &quot;LOCAL AUTHORITY&quot;\n  }\n</code></pre>\n<p>However the AccessToken added to the Http request is an access_token.\nHere's the <code>token_use</code> claim from the decoded JWT token added to the HTTP request:</p>\n<pre><code>  {\n    &quot;Type&quot;: &quot;token_use&quot;,\n    &quot;Value&quot;: &quot;access&quot;,\n    &quot;ValueType&quot;: &quot;http://www.w3.org/2001/XMLSchema#string&quot;,\n    &quot;Subject&quot;: null,\n    &quot;Properties&quot;: {},\n    &quot;OriginalIssuer&quot;: &quot;https://cognito-idp.ca-central-1.amazonaws.com/&lt;USER-POOL-ID&gt;&quot;,\n    &quot;Issuer&quot;: &quot;https://cognito-idp.ca-central-1.amazonaws.com/&lt;USER-POOL-ID&gt;&quot;\n  }\n</code></pre>\n<p>Which <em>sort of</em> makes sense since the Blazor API <em>is</em> <code>IAccessTokenProvider.RequestAccessToken()</code> ... there just doesn't seem to be an API to request the ID token.</p>\n"
}