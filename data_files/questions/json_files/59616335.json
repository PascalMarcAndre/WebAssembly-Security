{
    "tags": [
        "javascript",
        "performance",
        "scope"
    ],
    "owner": {
        "reputation": 257,
        "user_id": 7142530,
        "user_type": "registered",
        "accept_rate": 92,
        "profile_image": "https://www.gravatar.com/avatar/c5918be43fdf56f908c9a11216ce61d7?s=128&d=identicon&r=PG",
        "display_name": "Chris W",
        "link": "https://stackoverflow.com/users/7142530/chris-w"
    },
    "is_answered": true,
    "view_count": 184,
    "accepted_answer_id": 60491603,
    "answer_count": 1,
    "score": 8,
    "last_activity_date": 1583161635,
    "creation_date": 1578331161,
    "last_edit_date": 1583161635,
    "question_id": 59616335,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/59616335/can-anyone-explain-this-unexpected-v8-javascript-performance-behaviour",
    "title": "Can anyone explain this unexpected V8 JavaScript performance behaviour?",
    "body": "<h2>Update (Mar 2nd, 2020)</h2>\n\n<p>It turns out that the coding in my example here was structured in just the right way to fall off a known performance cliff in the V8 JavaScript engine...</p>\n\n<p>See the discussion over on <a href=\"https://bugs.chromium.org/p/v8/issues/detail?id=10100\" rel=\"nofollow noreferrer\">bugs.chromium.org</a> for the details.  This bug is now being worked on and should be fixed in the near future.</p>\n\n<h2>Update (Jan 9th, 2020)</h2>\n\n<p>I tried to isolate the coding that behaves in the manner described below into a single page Web app, but in doing so, the behaviour disappeared(??).  However, the behaviour described below does still exist in the context of the full application.</p>\n\n<p>That said, I have since optimised the fractal calculation coding and this problem is no longer an issue in the live version.  Should anyone be interested, the JavaScript module that manifests this problem is still available <a href=\"http://whealy.com/Rust/js/fractal_old.js\" rel=\"nofollow noreferrer\">here</a></p>\n\n<h1>Overview</h1>\n\n<p>I've just completed a small Web-based app to compare the performance of browser-based JavaScript with Web Assembly.  This app calculates a Mandelbrot Set image, then as you move the mouse pointer over that image, the corresponding Julia Set is dynamically calculated and the calculation time is displayed.</p>\n\n<p>You can switch between using JavaScript (press 'j') or WebAssembly (press 'w') to perform the calculation and compare runtimes.</p>\n\n<p>Click <a href=\"http://whealy.com/Rust/mandelbrot.html\" rel=\"nofollow noreferrer\">here</a> to see the working app</p>\n\n<p>However, in writing this code, I discovered some unexpectedly strange JavaScript performance behaviour...</p>\n\n<h1>Problem Summary</h1>\n\n<ol>\n<li><p>This problem seems to be specific to the V8 JavaScript engine used in Chrome and Brave.  This problem does not appear in browsers using SpiderMonkey (Firefox) or JavaScriptCore (Safari).  I have not been able to test this in a browser using the Chakra engine</p></li>\n<li><p>All the JavaScript code for this Web app has been written as <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules\" rel=\"nofollow noreferrer\">ES6 Modules</a></p></li>\n<li><p>I've tried rewriting all the functions using the traditional <code>function</code> syntax rather than the new ES6 arrow syntax.  Unfortunately, this does not make any appreciable difference</p></li>\n</ol>\n\n<p>The performance problem seems to relate to the scope within which a JavaScript function is created.  In this app, I call two partial functions, each of which gives me back another function.  I then pass these generated functions as arguments to another function that is called inside a nested <code>for</code> loop.</p>\n\n<p>Relative to the function within which it executes, it appears that a <code>for</code> loop creates something resembling its own scope (not sure its a full-blown scope though).  Then, passing generated functions across this scope(?) boundary is expensive.</p>\n\n<h1>Basic Coding Structure</h1>\n\n<p>Each partial function receives the X or Y value of the mouse pointer's position over the Mandelbrot Set image, and returns the function to be iterated when calculating the corresponding Julia set:</p>\n\n<pre><code>const makeJuliaXStepFn = mandelXCoord =&gt; (x, y) =&gt; mandelXCoord + diffOfSquares(x, y)\nconst makeJuliaYStepFn = mandelYCoord =&gt; (x, y) =&gt; mandelYCoord + (2 * x * y)\n</code></pre>\n\n<p>These functions are called within the following logic:</p>\n\n<ul>\n<li>The user moves the mouse pointer over the image of the Mandelbrot Set triggering the <code>mousemove</code> event</li>\n<li><p>The current location of the mouse pointer is translated to the coordinate space of Mandelbrot set and the (X,Y) coordinates are passed to function <code>juliaCalcJS</code> to calculate the corresponding Julia Set.</p></li>\n<li><p>When creating any particular Julia Set, the above two partial functions are called to generate the functions to be iterated when creating the Julia Set</p></li>\n<li><p>A nested <code>for</code> loop then calls function <code>juliaIter</code> to calculate the colour of every pixel in the Julia set.  The full coding can be seen <a href=\"http://whealy.com/Rust/js/fractal.js\" rel=\"nofollow noreferrer\">here</a>, but the essential logic is as follows:</p>\n\n<pre><code>const juliaCalcJS =\n  (cvs, juliaSpace) =&gt; {\n    // Snip - initialise canvas and create a new image array\n\n    // Generate functions for calculating the current Julia Set\n    let juliaXStepFn = makeJuliaXStepFn(juliaSpace.mandelXCoord)\n    let juliaYStepFn = makeJuliaYStepFn(juliaSpace.mandelYCoord)\n\n    // For each pixel in the canvas...\n    for (let iy = 0; iy &lt; cvs.height; ++iy) {\n      for (let ix = 0; ix &lt; cvs.width; ++ix) {\n        // Translate pixel values to coordinate space of Julia Set\n        let x_coord = juliaSpace.xMin + (juliaSpace.xMax - juliaSpace.xMin) * ix / (cvs.width - 1)\n        let y_coord = juliaSpace.yMin + (juliaSpace.yMax - juliaSpace.yMin) * iy / (cvs.height - 1)\n\n        // Calculate colour of the current pixel\n        let thisColour = juliaIter(x_coord, y_coord, juliaXStepFn, juliaYStepFn)\n\n        // Snip - Write pixel value to image array\n      }\n    }\n\n    // Snip - write image array to canvas\n  }\n</code></pre></li>\n<li><p>As you can see, the functions returned by calling <code>makeJuliaXStepFn</code> and <code>makeJuliaYStepFn</code> outside the <code>for</code> loop are passed to <code>juliaIter</code> which then does all the hard work of calculating the colour of the current pixel</p></li>\n</ul>\n\n<p>When I looked at this structure of code, at first I thought <em>\"This fine, it all works nicely; so nothing wrong here\"</em></p>\n\n<p>Except there was.  The performance was much slower than expected...</p>\n\n<h1>Unexpected Solution</h1>\n\n<p>Much head scratching and fiddling around followed...</p>\n\n<p>After a while, I discovered that if I move the creation of functions <code>juliaXStepFn</code> and <code>juliaYStepFn</code> inside either the outer or inner <code>for</code> loops, then the performance improves by a factor of between 2 and 3...</p>\n\n<p>WHAAAAAAT!?</p>\n\n<p>So, the code now looks like this</p>\n\n<pre><code>const juliaCalcJS =\n  (cvs, juliaSpace) =&gt; {\n    // Snip - initialise canvas and create a new image array\n\n    // For each pixel in the canvas...\n    for (let iy = 0; iy &lt; cvs.height; ++iy) {\n      // Generate functions for calculating the current Julia Set\n      let juliaXStepFn = makeJuliaXStepFn(juliaSpace.mandelXCoord)\n      let juliaYStepFn = makeJuliaYStepFn(juliaSpace.mandelYCoord)\n\n      for (let ix = 0; ix &lt; cvs.width; ++ix) {\n        // Translate pixel values to coordinate space of Julia Set\n        let x_coord = juliaSpace.xMin + (juliaSpace.xMax - juliaSpace.xMin) * ix / (cvs.width - 1)\n        let y_coord = juliaSpace.yMin + (juliaSpace.yMax - juliaSpace.yMin) * iy / (cvs.height - 1)\n\n        // Calculate colour of the current pixel\n        let thisColour = juliaIter(x_coord, y_coord, juliaXStepFn, juliaYStepFn)\n\n        // Snip - Write pixel value to image array\n      }\n    }\n\n    // Snip - write image array to canvas\n  }\n</code></pre>\n\n<p>I would have expected this seemingly insignificant change to be somewhat less efficient, because a pair of functions that do not need to change are being recreated each time we iterate the <code>for</code> loop.  Yet, by moving the function declarations inside the <code>for</code> loop, this code executes between 2 and 3 times faster! </p>\n\n<p>Can anyone explain this behaviour?</p>\n\n<p>Thanks</p>\n"
}