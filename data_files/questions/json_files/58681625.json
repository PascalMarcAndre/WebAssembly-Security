{
    "tags": [
        "c++",
        "v8",
        "embedded-v8"
    ],
    "owner": {
        "reputation": 78,
        "user_id": 9479817,
        "user_type": "registered",
        "profile_image": "https://lh3.googleusercontent.com/-XdUIqdMkCWA/AAAAAAAAAAI/AAAAAAAAAAA/4252rscbv5M/photo.jpg?sz=128",
        "display_name": "Yakir E",
        "link": "https://stackoverflow.com/users/9479817/yakir-e"
    },
    "is_answered": true,
    "view_count": 378,
    "accepted_answer_id": 58681913,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1572796728,
    "creation_date": 1572794751,
    "last_edit_date": 1572795649,
    "question_id": 58681625,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/58681625/call-webassembly-from-embedded-v8-with-imported-function",
    "title": "Call webassembly from embedded v8 with imported function",
    "body": "<p>Call webassembly with import statement from embedded v8 ( without JS )</p>\n\n<p>Following the thread <a href=\"https://stackoverflow.com/questions/53925972/call-webassembly-from-embedded-v8-without-js/\">Call webassembly from embedded v8 without JS</a> I was able to call a WebAssembly code directly from c++. My problem started when I tried to run a more \"complex\" code ( see attached code ) that includes an import statement. When trying to run this code I get a <strong>v8 error  WebAssembly.Instance(): Imports argument must be present and must be an object.</strong> \nI dag into the v8 code and found that this error happens when the module's import_table is empty ( v8/src/wasm/module-instantiate.cc#276 ).\nI think I need to provide the implementation of the imported function but I couldn't figure out how to do it. </p>\n\n<pre><code>#include &lt;include/v8.h&gt;\n\n#include &lt;include/libplatform/libplatform.h&gt;\n\nusing v8::HandleScope;\nusing v8::Isolate;\nusing v8::Local;\nusing v8::Promise;\nusing v8::WasmModuleObjectBuilderStreaming;\nusing v8::WasmCompiledModule;\nusing v8::Context;\nusing v8::Local;\nusing v8::Value;\nusing v8::String;\nusing v8::Object;\nusing v8::Function;\nusing v8::Int32;\nusing args_type = Local&lt;Value&gt;[];\n\nint main(int argc, char* argv[]) {\n  v8::V8::InitializeICUDefaultLocation(argv[0]);\n  v8::V8::InitializeExternalStartupData(argv[0]);\n  std::unique_ptr&lt;v8::Platform&gt; platform = v8::platform::NewDefaultPlatform();\n  v8::V8::InitializePlatform(platform.get());\n  v8::V8::Initialize();\n  Isolate::CreateParams create_params;\n  create_params.array_buffer_allocator = v8::ArrayBuffer::Allocator::NewDefaultAllocator();\n  Isolate* isolate = Isolate::New(create_params);\n  Isolate::Scope isolate_scope(isolate);\n  HandleScope scope(isolate);\n  Local&lt;Context&gt; context = Context::New(isolate);\n  Context::Scope context_scope(context);\n\n  WasmModuleObjectBuilderStreaming stream(isolate);\n\n    // Use the v8 API to generate a WebAssembly module.\n    //  compiled from the following c code \n    //  \n    //  #include &lt;stdlib.h&gt;\n    //  int add(int x, int y) {\n    //      return x + rand();\n    //  }\n    //  \n    //  produce the following wasm code \n    //  \n    //  (module\n    //  (type $FUNCSIG$i(func(result i32)))\n    //      (import \"env\" \"rand\" (func $rand(result i32)))\n    //      (table 0 anyfunc)\n    //      (memory $0 1)\n    //      (export \"memory\" (memory $0))\n    //      (export \"add\" (func $add))\n    //      (func $add(; 1;) (param $0 i32) (param $1 i32) (result i32)\n    //      (i32.add\n    //      (call $rand)\n    //          (get_local $0)\n    //          )\n    //          )\n    //      )\n    // \n    // binary representation of the above code \n    std::vector&lt;uint8_t&gt; wasmbin{\n            0x00 ,0x61 ,0x73 ,0x6d ,0x01 ,0x00 ,0x00 ,0x00 ,0x01 ,0x8b ,0x80 ,0x80 ,0x80 ,0x00 ,0x02 ,0x60 ,0x00 ,0x01 ,\n            0x7f ,0x60 ,0x02 ,0x7f ,0x7f ,0x01 ,0x7f ,0x02 ,0x8c ,0x80 ,0x80 ,0x80 ,0x00 ,0x01 ,0x03 ,0x65 ,0x6e ,0x76 ,\n            0x04 ,0x72 ,0x61 ,0x6e ,0x64 ,0x00 ,0x00 ,0x03 ,0x82 ,0x80 ,0x80 ,0x80 ,0x00 ,0x01 ,0x01 ,0x04 ,0x84 ,0x80 ,\n            0x80 ,0x80 ,0x00 ,0x01 ,0x70 ,0x00 ,0x00 ,0x05 ,0x83 ,0x80 ,0x80 ,0x80 ,0x00 ,0x01 ,0x00 ,0x01 ,0x06 ,0x81 ,\n            0x80 ,0x80 ,0x80 ,0x00 ,0x00 ,0x07 ,0x90 ,0x80 ,0x80 ,0x80 ,0x00 ,0x02 ,0x06 ,0x6d ,0x65 ,0x6d ,0x6f ,0x72 ,\n            0x79 ,0x02 ,0x00 ,0x03 ,0x61 ,0x64 ,0x64 ,0x00 ,0x01 ,0x0a ,0x8d ,0x80 ,0x80 ,0x80 ,0x00 ,0x01 ,0x87 ,0x80 ,\n            0x80 ,0x80 ,0x00 ,0x00 ,0x10 ,0x00 ,0x20 ,0x00 ,0x6a ,0x0b\n    };\n\n  // same as calling:\n  // let module = new WebAssembly.Module(bytes);\n  Local&lt;WasmCompiledModule&gt; module = WasmCompiledModule::DeserializeOrCompile(isolate,\n      WasmCompiledModule::BufferReference(0, 0),\n      WasmCompiledModule::BufferReference(wasmbin.data(), wasmbin.size())\n      ).ToLocalChecked();\n\n  // same as calling:\n  // let module_instance_exports = new WebAssembly.Instance(module).exports;\n  args_type instance_args{module};\n  Local&lt;Object&gt; module_instance_exports = context-&gt;Global()\n    -&gt;Get(context, String::NewFromUtf8(isolate, \"WebAssembly\"))\n    .ToLocalChecked().As&lt;Object&gt;()\n    -&gt;Get(context, String::NewFromUtf8(isolate, \"Instance\"))\n    .ToLocalChecked().As&lt;Object&gt;()\n    -&gt;CallAsConstructor(context, 1, instance_args)\n    .ToLocalChecked().As&lt;Object&gt;()\n    -&gt;Get(context, String::NewFromUtf8(isolate, \"exports\"))\n    .ToLocalChecked().As&lt;Object&gt;()\n    ;\n\n  // same as calling:\n  // module_instance_exports.add(77, 0)\n  args_type add_args{Int32::New(isolate, 77), Int32::New(isolate, 0)};\n  Local&lt;Int32&gt; adder_res = module_instance_exports\n    -&gt;Get(context, String::NewFromUtf8(isolate, \"add\"))\n    .ToLocalChecked().As&lt;Function&gt;()\n    -&gt;Call(context, context-&gt;Global(), 2, add_args)\n    .ToLocalChecked().As&lt;Int32&gt;();\n\n  printf(\"77 + rand() = %d\\n\", adder_res-&gt;Value());\n  return 0;\n}\n</code></pre>\n\n<p>Any help will be welcomed.</p>\n"
}