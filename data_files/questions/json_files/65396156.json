{
    "tags": [
        "asp.net-core",
        "authorization",
        "blazor",
        "webassembly"
    ],
    "owner": {
        "reputation": 224,
        "user_id": 5141561,
        "user_type": "registered",
        "accept_rate": 80,
        "profile_image": "https://graph.facebook.com/926750996976/picture?type=large",
        "display_name": "JoeyD",
        "link": "https://stackoverflow.com/users/5141561/joeyd"
    },
    "is_answered": true,
    "view_count": 80,
    "accepted_answer_id": 65469789,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1609098452,
    "creation_date": 1608567065,
    "last_edit_date": 1608585967,
    "question_id": 65396156,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/65396156/blazor-wasm-hosted-authorize-on-api-always-returns-unauthorized",
    "title": "Blazor WASM Hosted - Authorize on API Always returns UnAuthorized",
    "body": "<p>I have a blazor wasm hosted solution that is setup using Role authentication. However, whenever I add an [Authorize] attribute to any of my API Controllers I get a 401 Unauthorized. I know the user has the proper role as the UI is showing and hiding features for that role.  Its like the roles are not being passed up to the API.  What am I missing?</p>\n<p>Server - Starup.cs</p>\n<pre><code>public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        // For more information on how to configure your application, visit https://go.microsoft.com/fwlink/?LinkID=398940\n        public void ConfigureServices(IServiceCollection services)\n        {\n            //Register the Datacontext and Connection String\n            services.AddDbContext&lt;DataContext&gt;(options =&gt;\n                options.UseSqlServer(\n                    Configuration.GetConnectionString(&quot;DefaultConnection&quot;)));\n\n            services.AddDatabaseDeveloperPageExceptionFilter();\n\n            //Sets up the default Asp.net core Identity Screens - Use Identity Scaffolding to override defaults\n            services.AddDefaultIdentity&lt;ApplicationUser&gt;( options =&gt;\n                    {\n                        options.SignIn.RequireConfirmedAccount = true;\n                        options.Password.RequireDigit = true;\n                        options.Password.RequireLowercase = true;\n                        options.Password.RequireUppercase = true;\n                        options.Password.RequiredUniqueChars = 0;\n                        options.Password.RequireNonAlphanumeric = false;\n                        options.Password.RequiredLength = 8;\n                        options.User.RequireUniqueEmail = true;\n                    })\n                .AddRoles&lt;IdentityRole&gt;()\n                .AddEntityFrameworkStores&lt;DataContext&gt;();\n\n            //Associates the User to Context with Identity\n            services.AddIdentityServer()\n                .AddApiAuthorization&lt;ApplicationUser, DataContext&gt;( options =&gt;\n                {\n                    options.IdentityResources[&quot;openid&quot;].UserClaims.Add(JwtClaimTypes.Role);\n                    options.ApiResources.Single().UserClaims.Add(JwtClaimTypes.Role);\n                });\n\n            JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Remove(JwtClaimTypes.Role);\n\n            //Adds authentication handler\n            services.AddAuthentication().AddIdentityServerJwt();\n\n            //Register Repositories for Dependency Injection\n            services.AddScoped&lt;ICountryRepository, CountryRepository&gt;();\n\n            services.AddControllersWithViews();\n            services.AddRazorPages();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env, DataContext dataContext)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n                app.UseMigrationsEndPoint();\n                app.UseWebAssemblyDebugging();\n            }\n            else\n            {\n                app.UseExceptionHandler(&quot;/Error&quot;);\n                // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.\n                app.UseHsts();\n            }\n\n            //AutoMigrates data\n            dataContext.Database.Migrate();\n\n            app.UseHttpsRedirection();\n            app.UseBlazorFrameworkFiles();\n            app.UseStaticFiles();\n\n            app.UseSerilogIngestion();\n            app.UseSerilogRequestLogging();\n\n            app.UseRouting();\n\n            app.UseIdentityServer();\n            app.UseAuthentication();\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =&gt;\n            {\n                endpoints.MapRazorPages();\n                endpoints.MapControllers();\n                endpoints.MapFallbackToFile(&quot;index.html&quot;);\n            });\n        }\n    }\n</code></pre>\n<p>Client - Program.cs</p>\n<pre><code>public class Program\n    {\n        public static async Task Main(string[] args)\n        {\n            //Serilog \n            var levelSwitch = new LoggingLevelSwitch();\n            Log.Logger = new LoggerConfiguration()\n                .MinimumLevel.ControlledBy(levelSwitch)\n                .Enrich.WithProperty(&quot;InstanceId&quot;, Guid.NewGuid().ToString(&quot;n&quot;))\n                .WriteTo.BrowserHttp(controlLevelSwitch: levelSwitch)\n                .CreateLogger();\n\n            var builder = WebAssemblyHostBuilder.CreateDefault(args);\n            builder.RootComponents.Add&lt;App&gt;(&quot;#app&quot;);\n\n            builder.Services.AddHttpClient(&quot;XXX.ServerAPI&quot;, client =&gt; client.BaseAddress = new Uri(builder.HostEnvironment.BaseAddress))\n                .AddHttpMessageHandler&lt;BaseAddressAuthorizationMessageHandler&gt;();\n\n            // Supply HttpClient instances that include access tokens when making requests to the server project\n            builder.Services.AddScoped(sp =&gt; sp.GetRequiredService&lt;IHttpClientFactory&gt;().CreateClient(&quot;XXX.ServerAPI&quot;));\n\n            builder.Services.AddApiAuthorization()\n                .AddAccountClaimsPrincipalFactory&lt;RolesClaimsPrincipalFactory&gt;();\n\n            var baseAddress = new Uri($&quot;{builder.HostEnvironment.BaseAddress}api/&quot;); \n\n            void RegisterTypedClient&lt;TClient, TImplementation&gt;(Uri apiBaseUrl)\n                where TClient : class where TImplementation : class, TClient\n            {\n                builder.Services.AddHttpClient&lt;TClient, TImplementation&gt;(client =&gt;\n                {\n                    client.BaseAddress = apiBaseUrl;\n                });\n            }\n\n            RegisterTypedClient&lt;ICountryService, CountryService&gt;(baseAddress);\n\n\n            await builder.Build().RunAsync();\n        }\n    }\n</code></pre>\n<p>RolesClaimPrincipalFactory.cs</p>\n<pre><code>public class RolesClaimsPrincipalFactory : AccountClaimsPrincipalFactory&lt;RemoteUserAccount&gt;\n    {\n        public RolesClaimsPrincipalFactory(IAccessTokenProviderAccessor accessor) : base(accessor)\n        {\n        }\n\n        public async override ValueTask&lt;ClaimsPrincipal&gt; CreateUserAsync(\n            RemoteUserAccount account,\n            RemoteAuthenticationUserOptions options)\n        {\n            ClaimsPrincipal user = await base.CreateUserAsync(account, options);\n\n            if (user.Identity.IsAuthenticated)\n            {\n                var identity = (ClaimsIdentity)user.Identity;\n                Claim[] roleClaims = identity.FindAll(identity.RoleClaimType).ToArray();\n\n                if (roleClaims != null &amp;&amp; roleClaims.Any())\n                {\n                    foreach (Claim existingClaim in roleClaims)\n                    {\n                        identity.RemoveClaim(existingClaim);\n                    }\n\n                    var rolesElem = account.AdditionalProperties[identity.RoleClaimType];\n\n                    if (rolesElem is JsonElement roles)\n                    {\n                        if (roles.ValueKind == JsonValueKind.Array)\n                        {\n                            foreach (JsonElement role in roles.EnumerateArray())\n                            {\n                                identity.AddClaim(new Claim(options.RoleClaim, role.GetString()));\n                            }\n                        }\n                        else\n                        {\n                            identity.AddClaim(new Claim(options.RoleClaim, roles.GetString()));\n                        }\n                    }\n                }\n            }\n\n            return user;\n        }\n    }\n</code></pre>\n"
}