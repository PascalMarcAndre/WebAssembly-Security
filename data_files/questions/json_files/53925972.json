{
    "tags": [
        "c++",
        "v8",
        "webassembly"
    ],
    "owner": {
        "reputation": 103,
        "user_id": 10829442,
        "user_type": "registered",
        "profile_image": "https://lh3.googleusercontent.com/-OPJ-9w-2lQk/AAAAAAAAAAI/AAAAAAAAAAA/AKxrwcarNere7_BBVVKYA1WTpdan5nhiUQ/mo/photo.jpg?sz=128",
        "display_name": "mhk",
        "link": "https://stackoverflow.com/users/10829442/mhk"
    },
    "is_answered": true,
    "view_count": 1585,
    "accepted_answer_id": 53929545,
    "answer_count": 2,
    "score": 4,
    "last_activity_date": 1545847238,
    "creation_date": 1545776349,
    "last_edit_date": 1545833240,
    "question_id": 53925972,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/53925972/call-webassembly-from-embedded-v8-without-js",
    "title": "Call webassembly from embedded v8 without JS",
    "body": "<p>I would like to use webassembly directly from my embedded v8 without the detour via JavaScript. I used the provided <a href=\"https://github.com/v8/v8/blob/master/samples/hello-world.cc\" rel=\"nofollow noreferrer\">hello-world example</a> and the <a href=\"https://github.com/v8/v8/blob/master/include/v8.h#L4522\" rel=\"nofollow noreferrer\">WasmModuleObjectBuilderStreaming</a> class from <code>v8.h</code>. However, I am stuck at how to extract the <code>add</code> function. Help would be appreciated. </p>\n\n<pre><code>#include &lt;include/v8.h&gt;\n\n#include &lt;include/libplatform/libplatform.h&gt;\n\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nusing v8::HandleScope;\nusing v8::Isolate;\nusing v8::Local;\nusing v8::Promise;\nusing v8::WasmModuleObjectBuilderStreaming;\n\nint main(int argc, char* argv[]) {\n  v8::V8::InitializeICUDefaultLocation(argv[0]);\n  v8::V8::InitializeExternalStartupData(argv[0]);\n  std::unique_ptr&lt;v8::Platform&gt; platform = v8::platform::NewDefaultPlatform();\n  v8::V8::InitializePlatform(platform.get());\n  v8::V8::Initialize();\n  Isolate::CreateParams create_params;\n  create_params.array_buffer_allocator = v8::ArrayBuffer::Allocator::NewDefaultAllocator();\n  Isolate* isolate = Isolate::New(create_params);\n  Isolate::Scope isolate_scope(isolate);\n  HandleScope scope(isolate);\n\n  WasmModuleObjectBuilderStreaming stream(isolate);\n\n  // Use the v8 API to generate a WebAssembly module.\n  //\n  // |bytes| contains the binary format for the following module:\n  //\n  //     (func (export \"add\") (param i32 i32) (result i32)\n  //       get_local 0\n  //       get_local 1\n  //       i32.add)\n  //\n  // taken from: https://github.com/v8/v8/blob/master/samples/hello-world.cc#L66\n  std::vector&lt;uint8_t&gt; wasmbin {\n          0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0x01,\n          0x60, 0x02, 0x7f, 0x7f, 0x01, 0x7f, 0x03, 0x02, 0x01, 0x00, 0x07,\n          0x07, 0x01, 0x03, 0x61, 0x64, 0x64, 0x00, 0x00, 0x0a, 0x09, 0x01,\n          0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6a, 0x0b\n  };\n\n  // write bytes and finish\n  stream.OnBytesReceived(wasmbin.data(), wasmbin.size());\n  stream.Finish();\n  Local&lt;Promise&gt; promise = stream.GetPromise();\n\n  // TODO: Get exports, extract `add` &amp; call `add`\n}\n</code></pre>\n\n<p><strong>Build setup:</strong></p>\n\n<p>Follow the instruction in <em>Run the example</em> from the official <a href=\"https://v8.dev/docs/embed#run-the-example\" rel=\"nofollow noreferrer\">Getting started with embedding V8</a>. Save the code to <em>sample/wasm.cc</em> and execute following commands:</p>\n\n<pre><code>$ g++ -I. -O2 -Iinclude samples/wasm.cc -o wasm  -lv8_monolith -Lout.gn/x64.release.sample/obj/ -pthread -std=c++17`\n$ ./wasm`\n</code></pre>\n\n<p><strong>Solution:</strong></p>\n\n<p>Thanks <a href=\"https://stackoverflow.com/a/53929545\">@liliscent</a>, I adapted my example accordingly. Because we all like, working code:</p>\n\n<pre><code>#include &lt;include/v8.h&gt;\n\n#include &lt;include/libplatform/libplatform.h&gt;\n\nusing v8::HandleScope;\nusing v8::Isolate;\nusing v8::Local;\nusing v8::Promise;\nusing v8::WasmModuleObjectBuilderStreaming;\nusing v8::WasmCompiledModule;\nusing v8::Context;\nusing v8::Local;\nusing v8::Value;\nusing v8::String;\nusing v8::Object;\nusing v8::Function;\nusing v8::Int32;\nusing args_type = Local&lt;Value&gt;[];\n\nint main(int argc, char* argv[]) {\n  v8::V8::InitializeICUDefaultLocation(argv[0]);\n  v8::V8::InitializeExternalStartupData(argv[0]);\n  std::unique_ptr&lt;v8::Platform&gt; platform = v8::platform::NewDefaultPlatform();\n  v8::V8::InitializePlatform(platform.get());\n  v8::V8::Initialize();\n  Isolate::CreateParams create_params;\n  create_params.array_buffer_allocator = v8::ArrayBuffer::Allocator::NewDefaultAllocator();\n  Isolate* isolate = Isolate::New(create_params);\n  Isolate::Scope isolate_scope(isolate);\n  HandleScope scope(isolate);\n  Local&lt;Context&gt; context = Context::New(isolate);\n  Context::Scope context_scope(context);\n\n  WasmModuleObjectBuilderStreaming stream(isolate);\n\n  // Use the v8 API to generate a WebAssembly module.\n  //\n  // |bytes| contains the binary format for the following module: //\n  //     (func (export \"add\") (param i32 i32) (result i32)\n  //       get_local 0\n  //       get_local 1\n  //       i32.add)\n  //\n  // taken from: https://github.com/v8/v8/blob/master/samples/hello-world.cc#L66\n  std::vector&lt;uint8_t&gt; wasmbin {\n          0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0x01,\n          0x60, 0x02, 0x7f, 0x7f, 0x01, 0x7f, 0x03, 0x02, 0x01, 0x00, 0x07,\n          0x07, 0x01, 0x03, 0x61, 0x64, 0x64, 0x00, 0x00, 0x0a, 0x09, 0x01,\n          0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6a, 0x0b\n  };\n\n  // same as calling:\n  // let module = new WebAssembly.Module(bytes);\n  Local&lt;WasmCompiledModule&gt; module = WasmCompiledModule::DeserializeOrCompile(isolate,\n      WasmCompiledModule::BufferReference(0, 0),\n      WasmCompiledModule::BufferReference(wasmbin.data(), wasmbin.size())\n      ).ToLocalChecked();\n\n  // same as calling:\n  // let module_instance_exports = new WebAssembly.Instance(module).exports;\n  args_type instance_args{module};\n  Local&lt;Object&gt; module_instance_exports = context-&gt;Global()\n    -&gt;Get(context, String::NewFromUtf8(isolate, \"WebAssembly\"))\n    .ToLocalChecked().As&lt;Object&gt;()\n    -&gt;Get(context, String::NewFromUtf8(isolate, \"Instance\"))\n    .ToLocalChecked().As&lt;Object&gt;()\n    -&gt;CallAsConstructor(context, 1, instance_args)\n    .ToLocalChecked().As&lt;Object&gt;()\n    -&gt;Get(context, String::NewFromUtf8(isolate, \"exports\"))\n    .ToLocalChecked().As&lt;Object&gt;()\n    ;\n\n  // same as calling:\n  // module_instance_exports.add(77, 88)\n  args_type add_args{Int32::New(isolate, 77), Int32::New(isolate, 88)};\n  Local&lt;Int32&gt; adder_res = module_instance_exports\n    -&gt;Get(context, String::NewFromUtf8(isolate, \"add\"))\n    .ToLocalChecked().As&lt;Function&gt;()\n    -&gt;Call(context, context-&gt;Global(), 2, add_args)\n    .ToLocalChecked().As&lt;Int32&gt;();\n\n  printf(\"77 + 88 = %d\\n\", adder_res-&gt;Value());\n  return 0;\n}\n</code></pre>\n"
}