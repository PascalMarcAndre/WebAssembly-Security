[
    {
        "owner": {
            "reputation": 7044,
            "user_id": 7670262,
            "user_type": "registered",
            "profile_image": "https://i.stack.imgur.com/3zdDY.jpg?s=128&g=1",
            "display_name": "Azeem",
            "link": "https://stackoverflow.com/users/7670262/azeem"
        },
        "is_accepted": false,
        "score": 2,
        "last_activity_date": 1586607164,
        "creation_date": 1586607164,
        "answer_id": 61156588,
        "question_id": 61015985,
        "content_license": "CC BY-SA 4.0",
        "body": "<blockquote>\n  <p>How to detect (at JS side) an 'uncaught exception' coming from C++ code?</p>\n</blockquote>\n\n<p>You have to catch the exceptions using <code>try-catch</code> blocks (<a href=\"https://www.w3schools.com/js/js_errors.asp\" rel=\"nofollow noreferrer\">tutorial</a>).</p>\n\n<p>Example:</p>\n\n<pre><code>try {\n    console.log( fib(14) );\n}\ncatch ( e ) {\n    console.error( e );\n}\n</code></pre>\n\n<p>But, as of now, it is propagated as a pointer so you will see some number in the console:</p>\n\n<pre><code>5249672\n</code></pre>\n\n<p>If you want to get a proper error message in JS then you have to write a <a href=\"https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html#embind\" rel=\"nofollow noreferrer\">binding</a> in your C++ code:</p>\n\n<pre><code>#include &lt;emscripten/bind.h&gt;\n\nstd::string getExceptionMessage(int eptr)\n{\n    return reinterpret_cast&lt;std::exception*&gt;(eptr)-&gt;what();\n}\n\nEMSCRIPTEN_BINDINGS(getExceptionMessageBinding)\n{\n    emscripten::function(\"getExceptionMessage\", &amp;getExceptionMessage);\n};\n</code></pre>\n\n<p>This would be exposed in the JS code through the <code>Module</code> object. You can use it in JS code like this:</p>\n\n<pre><code>try {\n    console.log( fib(14) );\n}\ncatch ( e ) {\n    console.error( Module.getExceptionMessage(e) );\n}\n</code></pre>\n\n<p>Output (exception is thrown):</p>\n\n<pre><code>input out of range\n</code></pre>\n\n<p>Here's the GitHub <a href=\"https://github.com/emscripten-core/emscripten/issues/6330\" rel=\"nofollow noreferrer\">issue</a> where this has been discussed and <a href=\"https://github.com/emscripten-core/emscripten/issues/6330#issuecomment-568239092\" rel=\"nofollow noreferrer\">suggested</a>.</p>\n\n<p>I've compiled this code with exceptions enabled with C++11 and <a href=\"https://emscripten.org/docs/api_reference/bind.h.html#_CPPv419EMSCRIPTEN_BINDINGS4name\" rel=\"nofollow noreferrer\">bindings</a> like this:</p>\n\n<pre><code>~/emsdk/upstream/emscripten$ ./em++ -std=c++11 -Os -fexceptions --bind \n                             -s WASM=1\n                             -s EXTRA_EXPORTED_RUNTIME_METHODS='[\"cwrap\"]'\n                             -s DISABLE_EXCEPTION_CATCHING=0\n                             fib.cc\n</code></pre>\n\n<p>Here's another similar GitHub <a href=\"https://github.com/emscripten-core/emscripten/pull/7405\" rel=\"nofollow noreferrer\">issue</a> discussing another approach to this.</p>\n\n<hr>\n\n<blockquote>\n  <p>Adding exception catching functionality (<code>DISABLE_EXCEPTION_CATCHING=0</code>) seems to increase the file size too much.</p>\n</blockquote>\n\n<p>If your concern is the increased size of the output files, you can disable exception handling altogether and resort to error checking with invalid values or error codes returning by the function(s) e.g. -1 if the input is invalid.</p>\n\n<p>However, here's an observation:</p>\n\n<p>The file sizes of the previous build were:</p>\n\n<pre><code>110K - a.out.js\n187K - a.out.wasm\n</code></pre>\n\n<p>The exception handling and RTTI for bindings were part of this.</p>\n\n<p>I stripped the code and used inline JS using <a href=\"https://emscripten.org/docs/api_reference/emscripten.h.html#c.EM_ASM\" rel=\"nofollow noreferrer\">EM_ASM</a> to throw a JS Error in the following code snippet:</p>\n\n<pre><code>#include &lt;emscripten.h&gt;\n\nextern \"C\" {\n\nEMSCRIPTEN_KEEPALIVE\nint fib(int n) {\n    if (n &gt; 12) {\n        EM_ASM(\n            throw Error(\"out_of_range\");    // JS error with EM_ASM\n        );\n    }\n\n    int a {0}, b {1};\n    for ( int i {0}; i &lt; n; ++i ) {\n        const auto t = a + b;\n        a = b;\n        b = t;\n    }\n    return b;\n}\n\n}\n</code></pre>\n\n<p>Compiled with exceptions disabled:</p>\n\n<pre><code>$ ./em++ -std=c++11 -Os\n  -fno-exceptions \n  -s WASM=1\n  -s EXTRA_EXPORTED_RUNTIME_METHODS='[\"cwrap\"]'\n  fib1.cc\n</code></pre>\n\n<p>Here's the HTML file (<code>fib1.html</code>):</p>\n\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;WASM Test Page&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;script src=\"a.out.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\n\"use strict\";\n\nModule.onRuntimeInitialized = _ =&gt; {\n    const fib = Module.cwrap('fib', 'number', ['number']);\n\n    try {\n        console.log(fib(10));\n        console.log(fib(14));\n    }\n    catch ( e ) {\n        console.error(e);\n     }\n};\n\n&lt;/script&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n\n<p>Console Output (exception caught):</p>\n\n<pre><code>89\nfib1.html:21 Error: out_of_range\n    at Array.ASM_CONSTS (a.out.js:1)\n    at _emscripten_asm_const_i (a.out.js:1)\n    at wasm-function[1]:0x6b\n    at Module._fib (a.out.js:1)\n    at Object.Module.onRuntimeInitialized (fib1.html:18)\n    at doRun (a.out.js:1)\n    at run (a.out.js:1)\n    at runCaller (a.out.js:1)\n    at removeRunDependency (a.out.js:1)\n    at receiveInstance (a.out.js:1)\n</code></pre>\n\n<p>And, the file sizes were:</p>\n\n<pre><code>15K - a.out.js\n246 - a.out.wasm (bytes)\n</code></pre>\n\n<p>Throwing a JS Error still works with exceptions disabled and the generated file sizes are far less. You might want to explore this more. Maybe, create some classes inherited from Error with extended functionality. However, the exceptions that are thrown from the standard APIs such as <a href=\"https://en.cppreference.com/w/cpp/container/vector/at\" rel=\"nofollow noreferrer\"><code>std::vector::at()</code></a> won't work and cause termination. So, you need to be considerate about those while disabling exceptions.</p>\n\n<hr>\n\n<blockquote>\n  <p>How to reset/restart WebAssembly Module generated by <code>emcc</code> in a way that avoids memory leaks?</p>\n</blockquote>\n\n<p>As of now, there is no such API to reset/restart a module. The module itself is automatically garbage collected when it is no longer referenced. You don't have to care about the memory leak in this case. The JS runtime is responsible for this.</p>\n\n<p>But, the C++ object created by the JS code should be destroyed using <a href=\"https://emscripten.org/docs/api_reference/module.html#Module.destroy\" rel=\"nofollow noreferrer\"><code>Module.destroy</code></a> if it is managing resources (memory, file handles, etc.). The Garbage Collector (GC) won't call the destructor when it collects the object which would result in a memory/resource leak. Calling <code>Module.destory</code> will invoke the destructor and there won't be any memory leaks. Right now, your question doesn't have such an object. So, be mindful when you do and call <code>Module.destory</code> when required.</p>\n\n<p>As for the allocations/deallocations in your C++ code, you <em>yourself</em> are responsible for the deallocation of the resources that you allocate. Here are a few points that might help you in this regard:</p>\n\n<ul>\n<li><p>Avoid <a href=\"https://en.cppreference.com/w/cpp/language/ub\" rel=\"nofollow noreferrer\">Undefined Behavior</a>.</p></li>\n<li><p>Follow the <a href=\"https://en.cppreference.com/w/cpp/language/rule_of_three\" rel=\"nofollow noreferrer\">rule of three/five/zero</a> religiously.</p></li>\n<li><p>Use <a href=\"https://en.cppreference.com/w/cpp/language/raii\" rel=\"nofollow noreferrer\">RAII</a>-based C++ standard library facilities for automatic memory management such as <a href=\"https://en.cppreference.com/w/cpp/memory/unique_ptr\" rel=\"nofollow noreferrer\"><code>std::unique_ptr</code></a> / <a href=\"https://en.cppreference.com/w/cpp/memory/shared_ptr\" rel=\"nofollow noreferrer\"><code>std::shared_ptr</code></a> along with <a href=\"https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique\" rel=\"nofollow noreferrer\"><code>std::make_unique</code></a> / <a href=\"https://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared\" rel=\"nofollow noreferrer\"><code>std::make_shared</code></a>.</p></li>\n<li><p>Look for STL containers such as <a href=\"https://en.cppreference.com/w/cpp/container/vector\" rel=\"nofollow noreferrer\"><code>std::vector</code></a>, <a href=\"https://en.cppreference.com/w/cpp/container/map\" rel=\"nofollow noreferrer\"><code>std::map</code></a>, etc. for storing and managing collections rather than resorting to writing your own. The standard stuff is well-tested hence fewer worries about bugs.</p></li>\n<li><p>Always refer to the documentation of the APIs that you plan to use. Verify if an API allocates resources that you might have to deallocate a certain way after use.</p></li>\n</ul>\n\n<hr>\n\n<p>Here's a thread on loading a WASM module: <a href=\"https://developers.google.com/web/updates/2018/04/loading-wasm\" rel=\"nofollow noreferrer\">Loading WebAssembly modules efficiently</a></p>\n"
    }
]