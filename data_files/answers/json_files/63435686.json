[
    {
        "owner": {
            "reputation": 12718,
            "user_id": 2940908,
            "user_type": "registered",
            "accept_rate": 60,
            "profile_image": "https://i.stack.imgur.com/E79WU.jpg?s=128&g=1",
            "display_name": "agua from mars",
            "link": "https://stackoverflow.com/users/2940908/agua-from-mars"
        },
        "is_accepted": true,
        "score": 3,
        "last_activity_date": 1597576327,
        "creation_date": 1597576327,
        "answer_id": 63436153,
        "question_id": 63435686,
        "content_license": "CC BY-SA 4.0",
        "body": "<p>To secure a file download I use a one time token sent in the download request URI:</p>\n<ol>\n<li>Define a class to store one time toke</li>\n</ol>\n<pre class=\"lang-cs prettyprint-override\"><code>public class OneTimeToken\n{\n    public string Id { get; set; }\n\n    public string ClientId { get; set; }\n\n    public string UserId { get; set; }\n\n    public string Data { get; set; }\n}\n</code></pre>\n<p>I prefer to store tokens in DB but you can choose to store it in memory but server side obviously.</p>\n<ol start=\"2\">\n<li>Before download create a token</li>\n</ol>\n<p>Here I use a service calling an API to create my token</p>\n<pre class=\"lang-cs prettyprint-override\"><code>public class OneTimeTokenService\n{\n    private readonly IAdminStore&lt;OneTimeToken&gt; _store; // this my service calling the API\n    private readonly AuthenticationStateProvider _stateProvider;\n    private readonly IAccessTokenProvider _provider;\n    private readonly IOptions&lt;RemoteAuthenticationOptions&lt;OidcProviderOptions&gt;&gt; _options;\n\n    public OneTimeTokenService(IAdminStore&lt;OneTimeToken&gt; store,\n        AuthenticationStateProvider state,\n        IAccessTokenProvider provider,\n        IOptions&lt;RemoteAuthenticationOptions&lt;OidcProviderOptions&gt;&gt; options)\n    {\n        _store = store ?? throw new ArgumentNullException(nameof(store));\n        _stateProvider = state ?? throw new ArgumentNullException(nameof(state));\n        _provider = provider ?? throw new ArgumentNullException(nameof(provider));\n        _options = options ?? throw new ArgumentNullException(nameof(options));\n    }\n\n    public async Task&lt;string&gt; GetOneTimeToken()\n    {\n        // gets the user access token\n        var tokenResult = await _provider.RequestAccessToken().ConfigureAwait(false);\n        tokenResult.TryGetToken(out AccessToken token);\n        // gets the authentication state\n        var state = await _stateProvider.GetAuthenticationStateAsync().ConfigureAwait(false);\n        // creates a one time token\n        var oneTimeToken = await _store.CreateAsync(new OneTimeToken\n        {\n            ClientId = _options.Value.ProviderOptions.ClientId,\n            UserId = state.User.Claims.First(c =&gt; c.Type == &quot;sub&quot;).Value,\n            Expiration = DateTime.UtcNow.AddMinutes(1),\n            Data = token.Value\n        }).ConfigureAwait(false);\n\n        return oneTimeToken.Id;\n    }\n}\n</code></pre>\n<ol start=\"3\">\n<li>Create the download uri when the user click the download link</li>\n</ol>\n<p>Here I use a button, but it work with a any html element, you can use a link instead.</p>\n<pre class=\"lang-cs prettyprint-override\"><code>@inject OneTimeTokenService _service\n&lt;button class=&quot;btn btn-secondary&quot; @onclick=&quot;Download&quot; &gt;\n    &lt;span class=&quot;oi oi-arrow-circle-top&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sr-only&quot;&gt;Download \n    &lt;/span&gt;\n&lt;/button&gt;\n@code {\n    private async Task Download()\n    {\n        var token = await _service.GetOneTimeToken().ConfigureAwait(false);\n        var url = $&quot;http://locahost/stuff?otk={token}&quot;;\n        await _jsRuntime.InvokeVoidAsync(&quot;open&quot;, url, &quot;_blank&quot;).ConfigureAwait(false);\n    }\n}\n</code></pre>\n<ol start=\"4\">\n<li>Retrieve the token from the URL</li>\n</ol>\n<p>4.1. Add the package <code>IdentityServer4.AccessTokenValidation</code> to your API project.</p>\n<p>In Startup ConfigureServices method use the IdentityServer authentication:</p>\n<pre class=\"lang-cs prettyprint-override\"><code>services.AddTransient&lt;OneTimeTokenService&gt;()\n    .AddAuthentication()\n    .AddIdentityServerAuthentication(options =&gt;\n    {\n        options.TokenRetriever = request =&gt;\n        {\n            var oneTimeToken = TokenRetrieval.FromQueryString(&quot;otk&quot;)(request);\n            if (!string.IsNullOrEmpty(oneTimeToken))\n            {\n                return request.HttpContext\n                    .RequestServices\n                    .GetRequiredService&lt;OneTimeTokenService&gt;()\n                    .GetOneTimeToken(oneTimeToken);\n            }\n            return TokenRetrieval.FromAuthorizationHeader()(request);\n        };\n    });\n</code></pre>\n<ol start=\"5\">\n<li>Define a service to read and consume the one time token from the URI</li>\n</ol>\n<p>The token must not be reusable, so it's delete on each request.<br />\nHere it's just a sample. If you store tokens in DB you can use an EF context, if it's in memory, you can use an object cache for exemple.</p>\n<pre class=\"lang-cs prettyprint-override\"><code>public class OneTimeTokenService{\n    private readonly IAdminStore&lt;OneTimeToken&gt; _store;\n\n    public OneTimeTokenService(IAdminStore&lt;OneTimeToken&gt; store)\n    {\n        _store = store ?? throw new ArgumentNullException(nameof(store));\n    }\n\n    public string GetOneTimeToken(string id)\n    {\n        // gets the token.\n        var token = _store.GetAsync(id, new GetRequest()).GetAwaiter().GetResult();\n        if (token == null)\n        {\n            return null;\n        }\n        // deletes the token to not reuse it.\n        _store.DeleteAsync(id).GetAwaiter().GetResult();\n        return token.Data;\n    }\n}\n</code></pre>\n"
    }
]